/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/wheel-of-random.css":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/wheel-of-random.css ***!
  \*****************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".scene {\\n  border: 1px solid #CCC;\\n  position: relative;\\n  width: 100%;\\n  height: 100%;\\n  margin: 0;\\n  perspective: 500px;\\n}\\n\\n.carousel {\\n  width: 100%;\\n  height: 100%;\\n  position: absolute;\\n  transform: translateZ(-288px);\\n  transform-style: preserve-3d;\\n  transform-origin: center center;\\n  transition: transform 1s;\\n}\\n\\n.carousel__cell {\\n  position: absolute;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  width: 100%;\\n  height: 100%;\\n  left: 0px;\\n  top: 0px;\\n  border: 2px solid black;\\n  font-size: 62px;\\n  font-weight: bold;\\n  color: white;\\n  transition: transform 1s, opacity 1s;\\n  box-shadow:0 0 30px rgba(0,0,0,0.2)\\n}\\n\\n.carousel__cell.with-text-and-image{\\n    align-items: end;\\n    text-shadow: 0px 2px 3px rgba(0,0,0,0.3);\\n}\\n\\n.carousel__cell:nth-child(9n+1) { background: hsla(  0, 100%, 50%, 1); }\\n.carousel__cell:nth-child(9n+2) { background: hsla( 40, 100%, 50%, 1); }\\n.carousel__cell:nth-child(9n+3) { background: hsla( 80, 100%, 50%, 1); }\\n.carousel__cell:nth-child(9n+4) { background: hsla(120, 100%, 50%, 1); }\\n.carousel__cell:nth-child(9n+5) { background: hsla(160, 100%, 50%, 1); }\\n.carousel__cell:nth-child(9n+6) { background: hsla(200, 100%, 50%, 1); }\\n.carousel__cell:nth-child(9n+7) { background: hsla(240, 100%, 50%, 1); }\\n.carousel__cell:nth-child(9n+8) { background: hsla(280, 100%, 50%, 1); }\\n.carousel__cell:nth-child(9n+0) { background: hsla(320, 100%, 50%, 1); }\\n\\n.carousel__cell:nth-child(1) { transform: rotateX(  0deg) translateZ(288px); }\\n.carousel__cell:nth-child(2) { transform: rotateX( 40deg) translateZ(288px); }\\n.carousel__cell:nth-child(3) { transform: rotateX( 80deg) translateZ(288px); }\\n.carousel__cell:nth-child(4) { transform: rotateX(120deg) translateZ(288px); }\\n.carousel__cell:nth-child(5) { transform: rotateX(160deg) translateZ(288px); }\\n.carousel__cell:nth-child(6) { transform: rotateX(200deg) translateZ(288px); }\\n.carousel__cell:nth-child(7) { transform: rotateX(240deg) translateZ(288px); }\\n.carousel__cell:nth-child(8) { transform: rotateX(280deg) translateZ(288px); }\\n.carousel__cell:nth-child(9) { transform: rotateX(320deg) translateZ(288px); }\\n\\n\\n\\n.carousel-options {\\n  text-align: center;\\n  position: relative;\\n  z-index: 2;\\n  background: hsla(0, 0%, 100%, 0.8);\\n}\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://marketing-oembed-meeting-tools/./src/wheel-of-random.css?./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://marketing-oembed-meeting-tools/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://marketing-oembed-meeting-tools/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/wheel-of-random.css":
/*!*********************************!*\
  !*** ./src/wheel-of-random.css ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_wheel_of_random_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!../node_modules/postcss-loader/dist/cjs.js!./wheel-of-random.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/wheel-of-random.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_wheel_of_random_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_wheel_of_random_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_wheel_of_random_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_wheel_of_random_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://marketing-oembed-meeting-tools/./src/wheel-of-random.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://marketing-oembed-meeting-tools/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://marketing-oembed-meeting-tools/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://marketing-oembed-meeting-tools/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://marketing-oembed-meeting-tools/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://marketing-oembed-meeting-tools/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://marketing-oembed-meeting-tools/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/wheel-of-random.js":
/*!********************************!*\
  !*** ./src/wheel-of-random.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _wheel_of_random_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wheel-of-random.css */ \"./src/wheel-of-random.css\");\n/* harmony import */ var _liveblocks_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/client */ \"./node_modules/@liveblocks/client/index.mjs\");\n\n\n\n\n// Create a liveblocks client \nconst client = (0,_liveblocks_client__WEBPACK_IMPORTED_MODULE_1__.createClient)({\n    publicApiKey: \"pk_live_FdgtaGsHdpopKSR8i8ccvgSr\"\n});\n\nconst queryParams = new URLSearchParams(window.location.search);\nconst roomId = queryParams.get('sync-token');\nconst colors = ['hsla(  0, 100%, 50%, 1)', 'hsla( 40, 100%, 50%, 1)', 'hsla( 80, 100%, 50%, 1)', 'hsla(120, 100%, 50%, 1)', 'hsla(160, 100%, 50%, 1)', 'hsla(200, 100%, 50%, 1)', 'hsla(240, 100%, 50%, 1)', 'hsla(280, 100%, 50%, 1)', 'hsla(320, 100%, 50%, 1)', ];\n\nfunction randomNumber(size){\n    return Math.floor(Math.random() * size);\n}\n\nfunction randomColor(){\n    return colors[randomNumber(colors.length)];\n}\n\nfunction trapezoid(x,a,b,c,d) {\n\n    return Math.max(\n        Math.min(\n            (x-a)/(b-a),\n            1,\n            (d-x)/(d-c)\n        )\n        ,\n        0\n    )\n}\n\n\nlet spinningTimer = null;\nlet spinningAudioInterval = null\n\nlet view = {\n    attributes: {\n        'sync-token': queryParams.get('sync-token') || null,\n    },\n    models: {\n        carousel: null,\n        cells: [],\n        options: [],\n        tickSound: new Audio('Tick-DeepFrozenApps-397275646.mp3'),\n    },\n    actions: {\n        init: function(){\n\n            view.models.carousel = document.querySelector('.carousel');\n            view.attributes.selectedIndex = 0;\n            view.attributes.isHorizontal = false;\n            view.attributes.rotateFn = view.attributes.isHorizontal ? 'rotateY' : 'rotateX';\n            view.attributes.radius = null;\n            view.attributes.theta = null;\n            view.attributes.cameraDistance = 1;\n            view.attributes.isSpinning = false;\n            view.attributes.rotationsPerSpin = 3;\n            view.attributes.durationPerSpin = 7000; //ms\n\n            if(localStorage.getItem('options')){\n                view.models.options = JSON.parse(localStorage.getItem('options'));\n            }\n\n\n            var prevButton = document.querySelector('.previous-button');\n            prevButton.addEventListener( 'click', function() {\n                view.attributes.selectedIndex--;\n                view.actions.rotateCarousel(true, 300);\n            });\n            \n            var nextButton = document.querySelector('.next-button');\n            nextButton.addEventListener( 'click', function() {\n                view.attributes.selectedIndex++;\n                view.actions.rotateCarousel(true, 300);\n            });\n\n            var spinButton = document.querySelector('.spin-button');\n            spinButton.addEventListener( 'click', function() {\n                view.actions.spin();\n            });\n\n            var debounce = null;\n            window.addEventListener('resize', function(){\n                clearTimeout(debounce);\n                debounce = setTimeout(function(){\n                    view.actions.redrawCarousel();\n                }, 150)\n            });\n\n            var updateOptionsButton = document.querySelector('.update-options');\n            var optionsTextarea = document.querySelector('.options-textarea');\n            if(view.models.options.length){\n                var textareaContent = view.models.options.map(function(option){\n                    return option.stringCode;\n                }).join('\\n');\n                optionsTextarea.innerHTML=textareaContent;\n            }\n            updateOptionsButton.addEventListener('click', function(){\n                var options = [];\n                optionsTextarea.value.split('\\n').forEach(function(value){\n                    if(value.length){\n                        var label = value;\n                        var textColor = 'white';\n                        var bgColor = randomColor();\n                        var bgImg = '';\n                        var background = bgColor;\n                        var className = '';\n                        var opts = value.split(\"|\");\n                        \n\n                        if(opts.length == 3){\n                            label = opts[0];\n                            bgColor = opts[1];\n                            bgImg = opts[2];\n                            background = `${opts[1]} center / contain no-repeat url(\"${opts[2]}\")`;\n                            className = 'with-text-and-image';\n\n                        } else if(opts.length == 2){\n                            label = opts[0];\n                            bgColor = opts[1];\n                            background = bgColor;\n\n                        } else if(value.match(/^https?:\\/\\/.*\\/.*\\.(png|gif|webp|jpeg|jpg)($|\\?.*$)/)){\n                            label = '';\n                            background = `center / cover repeat url(\"${value}\")`;\n                        }\n\n                        options.push({\n                            label: label,\n                            text: textColor,\n                            background: background,\n                            className: className,\n                            visible: true,\n                            stringCode: `${value}`\n                        });\n                    }\n                });\n\n                view.models.options = options;\n                localStorage.setItem('options', JSON.stringify(view.models.options));\n                \n                view.actions.reloadOptions();\n                view.actions.redrawCarousel();\n            });\n\n            \n            // set initials\n            view.actions.reloadOptions();\n            view.actions.redrawCarousel();\n        },\n        spin: function(){\n            var winner = randomNumber(view.attributes.cellCount);\n            var incrementBy = view.attributes.rotationsPerSpin * view.attributes.cellCount + winner;\n\n            view.attributes.selectedIndex = view.attributes.selectedIndex + incrementBy;\n\n            console.log(`${view.actions.currentWinner().label} will win`);\n\n            view.actions.rotateCarousel(true, view.attributes.durationPerSpin);\n        },\n        currentWinner: function(){\n            return view.models.options[view.attributes.selectedIndex % 360 % view.attributes.cellCount];\n        },\n        redrawCarousel: function(){\n            view.attributes.cellWidth = view.models.carousel.offsetWidth;\n            view.attributes.cellHeight = view.models.carousel.offsetHeight;\n            view.actions.changeCarousel(false);\n        },\n        rotateCarousel: function(spin = true, spinDuration) {\n            \n            spinDuration = spinDuration || view.attributes.durationPerSpin;\n\n            if(spin){\n                view.models.carousel.classList.add('--spinning');\n                view.attributes.isSpinning = true;\n\n                view.models.tickSound.loop = true;\n                view.models.tickSound.playbackRate = 0.25;\n                view.models.tickSound.play();\n            } else {\n                spinDuration = 0;\n            }\n\n            var angle = view.attributes.theta * view.attributes.selectedIndex * -1;\n            view.models.carousel.style.transform = 'translateZ(' + -(view.attributes.radius + view.attributes.cameraDistance) + 'px) ' + view.attributes.rotateFn + '(' + angle + 'deg)';\n            view.models.carousel.style.transitionDuration = `${spinDuration}ms`;\n\n            if(spin){\n                clearTimeout(spinningTimer);\n                spinningTimer = setTimeout(function(){\n                    view.models.carousel.classList.remove('--spinning');\n                    view.attributes.isSpinning = false;\n                    view.models.tickSound.loop = false;\n                }, spinDuration);\n\n                var tickSteps = 0;\n                var tickStepsNeeded = (spinDuration-100)/100\n                \n                clearInterval(spinningAudioInterval);\n                spinningAudioInterval = setInterval(function(){\n                    if(view.attributes.isSpinning) {\n                        \n                        \n\n                        var percentComplete = (tickSteps / tickStepsNeeded) * 100\n                        view.models.tickSound.playbackRate = Math.max(0.15,trapezoid(percentComplete, 0,10,50,100)*1.5);\n                        if(view.models.tickSound.playbackRate < 0.25){\n                            view.models.tickSound.loop = false;\n                        } else {\n                            view.models.tickSound.loop = true;\n                        }\n\n                        view.models.tickSound.volume = 0.5 + trapezoid(percentComplete, 0,10,50,100) * 0.5;\n\n                        view.models.tickSound.play();\n\n\n                        tickSteps++;\n                    } else{\n                        clearInterval(spinningAudioInterval);\n                    }\n                }, 100);\n            }\n\n        },\n        changeCarousel: function(spin = true, spinDuration) {\n\n            view.attributes.theta = 360 / view.attributes.cellCount;\n\n            var cellSize = view.attributes.isHorizontal ? view.attributes.cellWidth : view.attributes.cellHeight;\n\n            view.attributes.radius = Math.round( ( cellSize / 2) / Math.tan( Math.PI / view.attributes.cellCount ) );\n\n            for ( var i=0; i < view.attributes.cellCount; i++ ) {\n              var cell = view.models.cells[i];\n              var option = view.models.options.at(i);\n              if ( i < view.attributes.cellCount) {\n                // visible cell\n                var cellAngle = view.attributes.theta * i;\n                cell.style.opacity = 1;\n                cell.style.transform = view.attributes.rotateFn + '(' + cellAngle + 'deg) translateZ(' + (view.attributes.radius || 1) + 'px)';\n                cell.style.transitionDuration = '0ms'\n                if(option.className.length){\n                    cell.classList.add(option.className);\n                }\n              } else {\n                // hidden cell\n                cell.style.opacity = 0;\n                cell.style.transform = 'none';\n              }\n            }\n          \n            view.actions.rotateCarousel(spin, spinDuration);\n        },\n        reloadOptions: function(){\n            var optionsArr = []\n            view.models.options.forEach(function(option, index){\n                if(option.visible){\n                    var optionEl = document.createElement('div');\n                    optionEl.className = 'carousel__cell';\n                    optionEl.innerHTML = `<div>\n                        <div>${option.label}</div>\n                        \n                    </div>`;\n                    optionEl.style.background = option.background;\n                    optionEl.style.color = option.text;\n                    optionEl.style.transitionDuration = '1000ms';\n\n                    optionEl.addEventListener('dblclick', function(){\n                        this.style.opacity = 0.5;\n                        setTimeout(function(){\n                            var currentlySelectedJSONString = JSON.stringify(view.actions.currentWinner());\n                            var currentlySelectedIndex = view.models.options.findIndex(function(value){\n                                return JSON.stringify(value) == currentlySelectedJSONString\n                            });\n\n\n                            optionEl.remove();\n                            view.models.options.splice(index, 1)\n\n                            if(currentlySelectedIndex > index){\n                                view.attributes.selectedIndex = currentlySelectedIndex - 1;\n                            } else {\n                                view.attributes.selectedIndex = currentlySelectedIndex;\n                            }\n\n                            //view.actions.reloadOptions();\n                            view.actions.reloadOptions();\n                            view.actions.redrawCarousel(true);\n\n                        }, 500);\n                    })\n\n                    optionsArr.push(optionEl);\n                }\n            });\n\n            view.models.carousel.innerHTML = '';\n            view.models.carousel.append(...optionsArr);\n\n            view.models.cells = view.models.carousel.querySelectorAll('.carousel__cell');\n            view.attributes.cellCount = view.models.cells.length;\n\n            view.attributes.cameraDistance = 1 * view.attributes.cellCount;\n\n            document.querySelector('.stage').style.height = `${(2-Math.min(1.4, Math.max( view.attributes.cellCount/16, 0))) * 30}vh`\n            view.attributes.cellWidth = view.models.carousel.offsetWidth;\n            view.attributes.cellHeight = view.models.carousel.offsetHeight;\n        }\n    }\n};\n\nwindow.view = view;\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n\n    view.actions.init();\n    \n\n});\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (view);\n\n//# sourceURL=webpack://marketing-oembed-meeting-tools/./src/wheel-of-random.js?");

/***/ }),

/***/ "./node_modules/@liveblocks/client/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@liveblocks/client/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LiveList\": () => (/* reexport safe */ _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   \"LiveMap\": () => (/* reexport safe */ _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   \"LiveObject\": () => (/* reexport safe */ _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.L),\n/* harmony export */   \"createClient\": () => (/* binding */ createClient)\n/* harmony export */ });\n/* harmony import */ var _shared_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared.mjs */ \"./node_modules/@liveblocks/client/shared.mjs\");\n\n\nconst BACKOFF_RETRY_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4],\n  BACKOFF_RETRY_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nfunction makeOthers(userMap) {\n  const users = Object.values(userMap).map((user) =>\n    (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__._)(user, [\"_hasReceivedInitialPresence\"])\n  );\n  return {\n    get count() {\n      return users.length;\n    },\n    [Symbol.iterator]: () => users[Symbol.iterator](),\n    map: (callback) => users.map(callback),\n    toArray: () => users,\n  };\n}\nfunction makeStateMachine(state, context, mockedEffects) {\n  const effects = mockedEffects || {\n    authenticate(auth, createWebSocket) {\n      const rawToken = state.token,\n        parsedToken = null !== rawToken && (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(rawToken);\n      if (!parsedToken || (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(parsedToken))\n        return auth(context.roomId)\n          .then(({ token: token }) => {\n            if (\"authenticating\" !== state.connection.state) return;\n            authenticationSuccess(\n              (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(token),\n              createWebSocket(token)\n            ),\n              (state.token = token);\n          })\n          .catch((er) =>\n            (function (error) {\n               true &&\n                console.error(\"Call to authentication endpoint failed\", error);\n              (state.token = null),\n                updateConnection({ state: \"unavailable\" }),\n                state.numberOfRetry++,\n                (state.timeoutHandles.reconnect = effects.scheduleReconnect(\n                  getRetryDelay()\n                ));\n            })(er instanceof Error ? er : new Error(String(er)))\n          );\n      authenticationSuccess(parsedToken, createWebSocket(rawToken));\n    },\n    send(messageOrMessages) {\n      if (null == state.socket)\n        throw new Error(\"Can't send message if socket is null\");\n      state.socket.send(JSON.stringify(messageOrMessages));\n    },\n    delayFlush: (delay) => setTimeout(tryFlushing, delay),\n    startHeartbeatInterval: () => setInterval(heartbeat, 3e4),\n    schedulePongTimeout: () => setTimeout(pongTimeout, 2e3),\n    scheduleReconnect: (delay) => setTimeout(connect, delay),\n  };\n  function genericSubscribe(callback) {\n    return (\n      state.listeners.storage.push(callback),\n      () => (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.r)(state.listeners.storage, callback)\n    );\n  }\n  function createOrUpdateRootFromMessage(message) {\n    if (0 === message.items.length)\n      throw new Error(\"Internal error: cannot load storage without items\");\n    state.root\n      ? (function (items) {\n          if (!state.root) return;\n          const currentItems = new Map();\n          state.items.forEach((liveCrdt, id) => {\n            currentItems.set(id, liveCrdt._toSerializedCrdt());\n          });\n          const ops = (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(currentItems, new Map(items));\n          notify(apply(ops, !1).updates);\n        })(message.items)\n      : (state.root = (function (items) {\n          const [root, parentToChildren] = (function (items) {\n            const parentToChildren = new Map();\n            let root = null;\n            for (const [id, crdt] of items)\n              if ((0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(crdt)) root = [id, crdt];\n              else {\n                const tuple = [id, crdt],\n                  children = parentToChildren.get(crdt.parentId);\n                null != children\n                  ? children.push(tuple)\n                  : parentToChildren.set(crdt.parentId, [tuple]);\n              }\n            if (null == root) throw new Error(\"Root can't be null\");\n            return [root, parentToChildren];\n          })(items);\n          return _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.L._deserialize(root, parentToChildren, {\n            getItem: getItem,\n            addItem: addItem,\n            deleteItem: deleteItem,\n            generateId: generateId,\n            generateOpId: generateOpId,\n            dispatch: storageDispatch,\n            roomId: context.roomId,\n          });\n        })(message.items));\n    for (const key in state.defaultStorageRoot)\n      null == state.root.get(key) &&\n        state.root.set(key, state.defaultStorageRoot[key]);\n  }\n  function addItem(id, liveItem) {\n    state.items.set(id, liveItem);\n  }\n  function deleteItem(id) {\n    state.items.delete(id);\n  }\n  function getItem(id) {\n    return state.items.get(id);\n  }\n  function addToUndoStack(historyItem) {\n    state.undoStack.length >= 50 && state.undoStack.shift(),\n      state.isHistoryPaused\n        ? state.pausedHistory.unshift(...historyItem)\n        : state.undoStack.push(historyItem);\n  }\n  function storageDispatch(ops, reverse, storageUpdates) {\n    state.isBatching\n      ? (state.batch.ops.push(...ops),\n        storageUpdates.forEach((value, key) => {\n          state.batch.updates.storageUpdates.set(\n            key,\n            (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.m)(\n              state.batch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }),\n        state.batch.reverseOps.push(...reverse))\n      : (addToUndoStack(reverse),\n        (state.redoStack = []),\n        dispatch(ops),\n        notify({ storageUpdates: storageUpdates }));\n  }\n  function notify({\n    storageUpdates: storageUpdates = new Map(),\n    presence: presence = !1,\n    others: otherEvents = [],\n  }) {\n    if (otherEvents.length > 0) {\n      state.others = makeOthers(state.users);\n      for (const event of otherEvents)\n        for (const listener of state.listeners.others)\n          listener(state.others, event);\n    }\n    if (presence)\n      for (const listener of state.listeners[\"my-presence\"]) listener(state.me);\n    if (storageUpdates.size > 0)\n      for (const subscriber of state.listeners.storage)\n        subscriber(Array.from(storageUpdates.values()));\n  }\n  function getConnectionId() {\n    if (\n      \"open\" === state.connection.state ||\n      \"connecting\" === state.connection.state\n    )\n      return state.connection.id;\n    if (null !== state.lastConnectionId) return state.lastConnectionId;\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function generateId() {\n    return `${getConnectionId()}:${state.clock++}`;\n  }\n  function generateOpId() {\n    return `${getConnectionId()}:${state.opClock++}`;\n  }\n  function apply(item, isLocal) {\n    const result = {\n        reverse: [],\n        updates: { storageUpdates: new Map(), presence: !1 },\n      },\n      createdNodeIds = new Set();\n    for (const op of item)\n      if (\"presence\" === op.type) {\n        const reverse = { type: \"presence\", data: {} };\n        for (const key in op.data) reverse.data[key] = state.me[key];\n        if (\n          ((state.me = Object.assign(Object.assign({}, state.me), op.data)),\n          null == state.buffer.presence)\n        )\n          state.buffer.presence = op.data;\n        else\n          for (const key in op.data) state.buffer.presence[key] = op.data[key];\n        result.reverse.unshift(reverse), (result.updates.presence = !0);\n      } else {\n        let source;\n        if ((op.opId || (op.opId = generateOpId()), isLocal))\n          source = _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.O.UNDOREDO_RECONNECT;\n        else {\n          source = state.offlineOperations.delete((0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(op.opId))\n            ? _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.O.ACK\n            : _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.O.REMOTE;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const parentId =\n            \"HasParent\" === applyOpResult.modified.node.parent.type\n              ? (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(\n                  applyOpResult.modified.node.parent.node._id,\n                  \"Expected parent node to have an ID\"\n                )\n              : void 0;\n          (parentId && createdNodeIds.has(parentId)) ||\n            (result.updates.storageUpdates.set(\n              (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(applyOpResult.modified.node._id),\n              (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.m)(\n                result.updates.storageUpdates.get(\n                  (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(applyOpResult.modified.node._id)\n                ),\n                applyOpResult.modified\n              )\n            ),\n            result.reverse.unshift(...applyOpResult.reverse)),\n            (op.type !== _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.e.CREATE_LIST &&\n              op.type !== _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.e.CREATE_MAP &&\n              op.type !== _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.e.CREATE_OBJECT) ||\n              createdNodeIds.add((0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(applyOpResult.modified.node._id));\n        }\n      }\n    return result;\n  }\n  function applyOp(op, source) {\n    switch (op.type) {\n      case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.e.DELETE_OBJECT_KEY:\n      case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.e.UPDATE_OBJECT:\n      case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.e.DELETE_CRDT: {\n        const item = state.items.get(op.id);\n        return null == item\n          ? { modified: !1 }\n          : item._apply(op, source === _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.O.UNDOREDO_RECONNECT);\n      }\n      case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.e.SET_PARENT_KEY: {\n        const item = state.items.get(op.id);\n        return null == item\n          ? { modified: !1 }\n          : \"HasParent\" === item.parent.type && (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(item.parent.node)\n          ? item.parent.node._setChildKey(op.parentKey, item, source)\n          : { modified: !1 };\n      }\n      case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.e.CREATE_OBJECT:\n      case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.e.CREATE_LIST:\n      case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.e.CREATE_MAP:\n      case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.e.CREATE_REGISTER: {\n        if (void 0 === op.parentId) return { modified: !1 };\n        const parent = state.items.get(op.parentId);\n        return null == parent\n          ? { modified: !1 }\n          : parent._attachChild(op, source);\n      }\n    }\n  }\n  function connect() {\n    var _a, _b, _c, _d;\n    if (\n      \"closed\" !== state.connection.state &&\n      \"unavailable\" !== state.connection.state\n    )\n      return null;\n    const auth = (function (authentication, fetchPolyfill) {\n        if (\"public\" === authentication.type) {\n          if (\"undefined\" == typeof window && null == fetchPolyfill)\n            throw new Error(\n              \"To use Liveblocks client in a non-dom environment with a publicApiKey, you need to provide a fetch polyfill.\"\n            );\n          return (room) =>\n            fetchAuthEndpoint(fetchPolyfill || fetch, authentication.url, {\n              room: room,\n              publicApiKey: authentication.publicApiKey,\n            });\n        }\n        if (\"private\" === authentication.type) {\n          if (\"undefined\" == typeof window && null == fetchPolyfill)\n            throw new Error(\n              \"To use Liveblocks client in a non-dom environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n            );\n          return (room) =>\n            fetchAuthEndpoint(fetchPolyfill || fetch, authentication.url, {\n              room: room,\n            });\n        }\n        if (\"custom\" === authentication.type) {\n          return (room) =>\n            authentication.callback(room).then((response) => {\n              if (!response || !response.token)\n                throw new Error(\n                  'Authentication error. We expect the authentication callback to return a token, but it does not. Hint: the return value should look like: { token: \"...\" }'\n                );\n              return response;\n            });\n        }\n        throw new Error(\"Internal error. Unexpected authentication type\");\n      })(\n        context.authentication,\n        null !==\n          (_b =\n            null === (_a = context.polyfills) || void 0 === _a\n              ? void 0\n              : _a.fetch) && void 0 !== _b\n          ? _b\n          : context.fetchPolyfill\n      ),\n      createWebSocket = (function (liveblocksServer, WebSocketPolyfill) {\n        if (\"undefined\" == typeof window && null == WebSocketPolyfill)\n          throw new Error(\n            \"To use Liveblocks client in a non-dom environment, you need to provide a WebSocket polyfill.\"\n          );\n        const ws = WebSocketPolyfill || WebSocket;\n        return (token) =>\n          new ws(`${liveblocksServer}/?token=${token}&version=0.17.1`);\n      })(\n        context.liveblocksServer,\n        null !==\n          (_d =\n            null === (_c = context.polyfills) || void 0 === _c\n              ? void 0\n              : _c.WebSocket) && void 0 !== _d\n          ? _d\n          : context.WebSocketPolyfill\n      );\n    updateConnection({ state: \"authenticating\" }),\n      effects.authenticate(auth, createWebSocket);\n  }\n  function authenticationSuccess(token, socket) {\n    socket.addEventListener(\"message\", onMessage),\n      socket.addEventListener(\"open\", onOpen),\n      socket.addEventListener(\"close\", onClose),\n      socket.addEventListener(\"error\", onError),\n      updateConnection({\n        state: \"connecting\",\n        id: token.actor,\n        userInfo: token.info,\n        userId: token.id,\n      }),\n      (state.idFactory = (function (connectionId) {\n        let count = 0;\n        return () => `${connectionId}:${count++}`;\n      })(token.actor)),\n      (state.socket = socket);\n  }\n  function onUpdatePresenceMessage(message) {\n    const user = state.users[message.actor];\n    if (\n      void 0 !== message.targetActor ||\n      null == user ||\n      user._hasReceivedInitialPresence\n    )\n      return (\n        (state.users[message.actor] =\n          null == user\n            ? {\n                connectionId: message.actor,\n                presence: message.data,\n                id: void 0,\n                info: void 0,\n                _hasReceivedInitialPresence: !0,\n              }\n            : {\n                id: user.id,\n                info: user.info,\n                connectionId: message.actor,\n                presence: Object.assign(\n                  Object.assign({}, user.presence),\n                  message.data\n                ),\n                _hasReceivedInitialPresence: !0,\n              }),\n        {\n          type: \"update\",\n          updates: message.data,\n          user: state.users[message.actor],\n        }\n      );\n  }\n  function onUserLeftMessage(message) {\n    const userLeftMessage = message,\n      user = state.users[userLeftMessage.actor];\n    return user\n      ? (delete state.users[userLeftMessage.actor],\n        { type: \"leave\", user: user })\n      : null;\n  }\n  function onRoomStateMessage(message) {\n    const newUsers = {};\n    for (const key in message.users) {\n      const connectionId = Number.parseInt(key),\n        user = message.users[key];\n      newUsers[connectionId] = {\n        connectionId: connectionId,\n        info: user.info,\n        id: user.id,\n      };\n    }\n    return (state.users = newUsers), { type: \"reset\" };\n  }\n  function onEvent(message) {\n    for (const listener of state.listeners.event)\n      listener({ connectionId: message.actor, event: message.event });\n  }\n  function onUserJoinedMessage(message) {\n    return (\n      (state.users[message.actor] = {\n        connectionId: message.actor,\n        info: message.info,\n        id: message.id,\n        _hasReceivedInitialPresence: !0,\n      }),\n      state.me &&\n        (state.buffer.messages.push({\n          type: _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.C.UPDATE_PRESENCE,\n          data: state.me,\n          targetActor: message.actor,\n        }),\n        tryFlushing()),\n      { type: \"enter\", user: state.users[message.actor] }\n    );\n  }\n  function parseServerMessage(data) {\n    return (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.l)(data) ? data : null;\n  }\n  function onMessage(event) {\n    if (\"pong\" === event.data)\n      return void clearTimeout(state.timeoutHandles.pongTimeout);\n    const messages = (function (text) {\n      const data = (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(text);\n      return void 0 === data\n        ? null\n        : (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(data)\n        ? (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(data.map((item) => parseServerMessage(item)))\n        : (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.j)([parseServerMessage(data)]);\n    })(event.data);\n    if (null === messages || 0 === messages.length) return;\n    const updates = { storageUpdates: new Map(), others: [] };\n    for (const message of messages)\n      switch (message.type) {\n        case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.S.USER_JOINED:\n          updates.others.push(onUserJoinedMessage(message));\n          break;\n        case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.S.UPDATE_PRESENCE: {\n          const othersPresenceUpdate = onUpdatePresenceMessage(message);\n          othersPresenceUpdate && updates.others.push(othersPresenceUpdate);\n          break;\n        }\n        case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.S.BROADCASTED_EVENT:\n          onEvent(message);\n          break;\n        case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.S.USER_LEFT: {\n          const event = onUserLeftMessage(message);\n          event && updates.others.push(event);\n          break;\n        }\n        case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.S.ROOM_STATE:\n          updates.others.push(onRoomStateMessage(message));\n          break;\n        case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.S.INITIAL_STORAGE_STATE: {\n          const offlineOps = new Map(state.offlineOperations);\n          createOrUpdateRootFromMessage(message),\n            applyAndSendOfflineOps(offlineOps),\n            null == _getInitialStateResolver || _getInitialStateResolver();\n          break;\n        }\n        case _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.S.UPDATE_STORAGE:\n          apply(message.ops, !1).updates.storageUpdates.forEach(\n            (value, key) => {\n              updates.storageUpdates.set(\n                key,\n                (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.m)(updates.storageUpdates.get(key), value)\n              );\n            }\n          );\n          break;\n      }\n    notify(updates);\n  }\n  function onClose(event) {\n    if (\n      ((state.socket = null),\n      clearTimeout(state.timeoutHandles.pongTimeout),\n      clearInterval(state.intervalHandles.heartbeat),\n      state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush),\n      clearTimeout(state.timeoutHandles.reconnect),\n      (state.users = {}),\n      notify({ others: [{ type: \"reset\" }] }),\n      event.code >= 4e3 && event.code <= 4100)\n    ) {\n      updateConnection({ state: \"failed\" });\n      const error = new LiveblocksError(event.reason, event.code);\n      for (const listener of state.listeners.error) listener(error);\n      const delay = getRetryDelay(!0);\n      state.numberOfRetry++,\n         true &&\n          console.error(\n            `Connection to Liveblocks websocket server closed. Reason: ${error.message} (code: ${error.code}). Retrying in ${delay}ms.`\n          ),\n        updateConnection({ state: \"unavailable\" }),\n        (state.timeoutHandles.reconnect = effects.scheduleReconnect(delay));\n    } else if (event.code === _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.W.CLOSE_WITHOUT_RETRY)\n      updateConnection({ state: \"closed\" });\n    else {\n      const delay = getRetryDelay();\n      state.numberOfRetry++,\n         true &&\n          console.warn(\n            `Connection to Liveblocks websocket server closed (code: ${event.code}). Retrying in ${delay}ms.`\n          ),\n        updateConnection({ state: \"unavailable\" }),\n        (state.timeoutHandles.reconnect = effects.scheduleReconnect(delay));\n    }\n  }\n  function updateConnection(connection) {\n    state.connection = connection;\n    for (const listener of state.listeners.connection)\n      listener(connection.state);\n  }\n  function getRetryDelay(slow = !1) {\n    return slow\n      ? BACKOFF_RETRY_DELAYS_SLOW[\n          state.numberOfRetry < BACKOFF_RETRY_DELAYS_SLOW.length\n            ? state.numberOfRetry\n            : BACKOFF_RETRY_DELAYS_SLOW.length - 1\n        ]\n      : BACKOFF_RETRY_DELAYS[\n          state.numberOfRetry < BACKOFF_RETRY_DELAYS.length\n            ? state.numberOfRetry\n            : BACKOFF_RETRY_DELAYS.length - 1\n        ];\n  }\n  function onError() {}\n  function onOpen() {\n    clearInterval(state.intervalHandles.heartbeat),\n      (state.intervalHandles.heartbeat = effects.startHeartbeatInterval()),\n      \"connecting\" === state.connection.state &&\n        (updateConnection(\n          Object.assign(Object.assign({}, state.connection), { state: \"open\" })\n        ),\n        (state.numberOfRetry = 0),\n        void 0 !== state.lastConnectionId &&\n          ((state.buffer.presence = state.me), tryFlushing()),\n        (state.lastConnectionId = state.connection.id),\n        state.root &&\n          state.buffer.messages.push({ type: _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.C.FETCH_STORAGE }),\n        tryFlushing());\n  }\n  function heartbeat() {\n    null != state.socket &&\n      (clearTimeout(state.timeoutHandles.pongTimeout),\n      (state.timeoutHandles.pongTimeout = effects.schedulePongTimeout()),\n      state.socket.readyState === state.socket.OPEN &&\n        state.socket.send(\"ping\"));\n  }\n  function pongTimeout() {\n    reconnect();\n  }\n  function reconnect() {\n    state.socket &&\n      (state.socket.removeEventListener(\"open\", onOpen),\n      state.socket.removeEventListener(\"message\", onMessage),\n      state.socket.removeEventListener(\"close\", onClose),\n      state.socket.removeEventListener(\"error\", onError),\n      state.socket.close(),\n      (state.socket = null)),\n      updateConnection({ state: \"unavailable\" }),\n      clearTimeout(state.timeoutHandles.pongTimeout),\n      state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush),\n      clearTimeout(state.timeoutHandles.reconnect),\n      clearInterval(state.intervalHandles.heartbeat),\n      connect();\n  }\n  function applyAndSendOfflineOps(offlineOps) {\n    if (0 === offlineOps.size) return;\n    const messages = [],\n      ops = Array.from(offlineOps.values()),\n      result = apply(ops, !0);\n    messages.push({ type: _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.C.UPDATE_STORAGE, ops: ops }),\n      notify(result.updates),\n      effects.send(messages);\n  }\n  function tryFlushing() {\n    const storageOps = state.buffer.storageOperations;\n    if (\n      (storageOps.length > 0 &&\n        storageOps.forEach((op) => {\n          state.offlineOperations.set((0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(op.opId), op);\n        }),\n      null == state.socket || state.socket.readyState !== state.socket.OPEN)\n    )\n      return void (state.buffer.storageOperations = []);\n    const now = Date.now();\n    if (now - state.lastFlushTime > context.throttleDelay) {\n      const messages = (function (state) {\n        const messages = [];\n        state.buffer.presence &&\n          messages.push({\n            type: _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.C.UPDATE_PRESENCE,\n            data: state.buffer.presence,\n          });\n        for (const event of state.buffer.messages) messages.push(event);\n        state.buffer.storageOperations.length > 0 &&\n          messages.push({\n            type: _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.C.UPDATE_STORAGE,\n            ops: state.buffer.storageOperations,\n          });\n        return messages;\n      })(state);\n      if (0 === messages.length) return;\n      effects.send(messages),\n        (state.buffer = {\n          messages: [],\n          storageOperations: [],\n          presence: null,\n        }),\n        (state.lastFlushTime = now);\n    } else\n      null != state.timeoutHandles.flush &&\n        clearTimeout(state.timeoutHandles.flush),\n        (state.timeoutHandles.flush = effects.delayFlush(\n          context.throttleDelay - (now - state.lastFlushTime)\n        ));\n  }\n  function getPresence() {\n    return state.me;\n  }\n  function dispatch(ops) {\n    state.buffer.storageOperations.push(...ops), tryFlushing();\n  }\n  let _getInitialStatePromise = null,\n    _getInitialStateResolver = null;\n  return {\n    onClose: onClose,\n    onMessage: onMessage,\n    authenticationSuccess: authenticationSuccess,\n    heartbeat: heartbeat,\n    onNavigatorOnline: function () {\n      \"unavailable\" === state.connection.state && reconnect();\n    },\n    simulateSocketClose: function () {\n      state.socket && (state.socket = null);\n    },\n    simulateSendCloseEvent: function (event) {\n      onClose(event);\n    },\n    onVisibilityChange: function (visibilityState) {\n      \"visible\" === visibilityState &&\n        \"open\" === state.connection.state &&\n        heartbeat();\n    },\n    getUndoStack: () => state.undoStack,\n    getItemsCount: () => state.items.size,\n    connect: connect,\n    disconnect: function () {\n      state.socket &&\n        (state.socket.removeEventListener(\"open\", onOpen),\n        state.socket.removeEventListener(\"message\", onMessage),\n        state.socket.removeEventListener(\"close\", onClose),\n        state.socket.removeEventListener(\"error\", onError),\n        state.socket.close(),\n        (state.socket = null)),\n        updateConnection({ state: \"closed\" }),\n        state.timeoutHandles.flush && clearTimeout(state.timeoutHandles.flush),\n        clearTimeout(state.timeoutHandles.reconnect),\n        clearTimeout(state.timeoutHandles.pongTimeout),\n        clearInterval(state.intervalHandles.heartbeat),\n        (state.users = {}),\n        notify({ others: [{ type: \"reset\" }] }),\n        (function () {\n          for (const key in state.listeners) state.listeners[key] = [];\n        })();\n    },\n    subscribe: function (first, second, options) {\n      if (void 0 === second || \"function\" == typeof first) {\n        if (\"function\" == typeof first) {\n          return genericSubscribe(first);\n        }\n        throw new Error(\"Please specify a listener callback\");\n      }\n      if ((0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(first)) {\n        const node = first;\n        if (null == options ? void 0 : options.isDeep) {\n          return (function (node, callback) {\n            return genericSubscribe((updates) => {\n              const relatedUpdates = updates.filter((update) =>\n                (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.d)(update.node, node)\n              );\n              relatedUpdates.length > 0 && callback(relatedUpdates);\n            });\n          })(node, second);\n        }\n        return (function (node, callback) {\n          return genericSubscribe((updates) => {\n            for (const update of updates)\n              update.node._id === node._id && callback(update.node);\n          });\n        })(node, second);\n      }\n      if (!(0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(first))\n        throw new Error(`\"${first}\" is not a valid event name`);\n      const eventName = first,\n        eventListener = second;\n      return (\n        state.listeners[eventName].push(eventListener),\n        () => {\n          const callbacks = state.listeners[eventName];\n          (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.r)(callbacks, eventListener);\n        }\n      );\n    },\n    updatePresence: function (overrides, options) {\n      const oldValues = {};\n      null == state.buffer.presence && (state.buffer.presence = {});\n      for (const key in overrides) {\n        const overrideValue = overrides[key];\n        void 0 !== overrideValue &&\n          ((state.buffer.presence[key] = overrideValue),\n          (oldValues[key] = state.me[key]));\n      }\n      (state.me = Object.assign(Object.assign({}, state.me), overrides)),\n        state.isBatching\n          ? ((null == options ? void 0 : options.addToHistory) &&\n              state.batch.reverseOps.push({\n                type: \"presence\",\n                data: oldValues,\n              }),\n            (state.batch.updates.presence = !0))\n          : (tryFlushing(),\n            (null == options ? void 0 : options.addToHistory) &&\n              addToUndoStack([{ type: \"presence\", data: oldValues }]),\n            notify({ presence: !0 }));\n    },\n    broadcastEvent: function (\n      event,\n      options = { shouldQueueEventIfNotReady: !1 }\n    ) {\n      (null == state.socket && 0 == options.shouldQueueEventIfNotReady) ||\n        (state.buffer.messages.push({\n          type: _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.C.BROADCAST_EVENT,\n          event: event,\n        }),\n        tryFlushing());\n    },\n    batch: function (callback) {\n      if (state.isBatching)\n        throw new Error(\"batch should not be called during a batch\");\n      state.isBatching = !0;\n      try {\n        callback();\n      } finally {\n        (state.isBatching = !1),\n          state.batch.reverseOps.length > 0 &&\n            addToUndoStack(state.batch.reverseOps),\n          state.batch.ops.length > 0 && (state.redoStack = []),\n          state.batch.ops.length > 0 && dispatch(state.batch.ops),\n          notify(state.batch.updates),\n          (state.batch = {\n            ops: [],\n            reverseOps: [],\n            updates: { others: [], storageUpdates: new Map(), presence: !1 },\n          }),\n          tryFlushing();\n      }\n    },\n    undo: function () {\n      if (state.isBatching)\n        throw new Error(\"undo is not allowed during a batch\");\n      const historyItem = state.undoStack.pop();\n      if (null == historyItem) return;\n      state.isHistoryPaused = !1;\n      const result = apply(historyItem, !0);\n      notify(result.updates), state.redoStack.push(result.reverse);\n      for (const op of historyItem)\n        \"presence\" !== op.type && state.buffer.storageOperations.push(op);\n      tryFlushing();\n    },\n    redo: function () {\n      if (state.isBatching)\n        throw new Error(\"redo is not allowed during a batch\");\n      const historyItem = state.redoStack.pop();\n      if (null == historyItem) return;\n      state.isHistoryPaused = !1;\n      const result = apply(historyItem, !0);\n      notify(result.updates), state.undoStack.push(result.reverse);\n      for (const op of historyItem)\n        \"presence\" !== op.type && state.buffer.storageOperations.push(op);\n      tryFlushing();\n    },\n    pauseHistory: function () {\n      (state.pausedHistory = []), (state.isHistoryPaused = !0);\n    },\n    resumeHistory: function () {\n      (state.isHistoryPaused = !1),\n        state.pausedHistory.length > 0 && addToUndoStack(state.pausedHistory),\n        (state.pausedHistory = []);\n    },\n    getStorage: function () {\n      return state.root\n        ? new Promise((resolve) => resolve({ root: state.root }))\n        : (null == _getInitialStatePromise &&\n            (state.buffer.messages.push({ type: _shared_mjs__WEBPACK_IMPORTED_MODULE_0__.C.FETCH_STORAGE }),\n            tryFlushing(),\n            (_getInitialStatePromise = new Promise(\n              (resolve) => (_getInitialStateResolver = resolve)\n            ))),\n          _getInitialStatePromise.then(() => ({ root: (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(state.root) })));\n    },\n    selectors: {\n      getConnectionState: function () {\n        return state.connection.state;\n      },\n      getSelf: function () {\n        return \"open\" === state.connection.state ||\n          \"connecting\" === state.connection.state\n          ? {\n              connectionId: state.connection.id,\n              id: state.connection.userId,\n              info: state.connection.userInfo,\n              presence: getPresence(),\n            }\n          : null;\n      },\n      getPresence: getPresence,\n      getOthers: function () {\n        return state.others;\n      },\n    },\n  };\n}\nfunction createRoom(options, context) {\n  var _a, _b;\n  const initialPresence =\n      null !== (_a = options.initialPresence) && void 0 !== _a\n        ? _a\n        : options.defaultPresence,\n    initialStorage =\n      null !== (_b = options.initialStorage) && void 0 !== _b\n        ? _b\n        : options.defaultStorageRoot,\n    machine = makeStateMachine(\n      (function (initialPresence, initialStorage) {\n        return {\n          connection: { state: \"closed\" },\n          token: null,\n          lastConnectionId: null,\n          socket: null,\n          listeners: {\n            event: [],\n            others: [],\n            \"my-presence\": [],\n            error: [],\n            connection: [],\n            storage: [],\n          },\n          numberOfRetry: 0,\n          lastFlushTime: 0,\n          timeoutHandles: { flush: null, reconnect: 0, pongTimeout: 0 },\n          buffer: {\n            presence: null == initialPresence ? {} : initialPresence,\n            messages: [],\n            storageOperations: [],\n          },\n          intervalHandles: { heartbeat: 0 },\n          me: null == initialPresence ? {} : initialPresence,\n          users: {},\n          others: makeOthers({}),\n          defaultStorageRoot: initialStorage,\n          idFactory: null,\n          clock: 0,\n          opClock: 0,\n          items: new Map(),\n          root: void 0,\n          undoStack: [],\n          redoStack: [],\n          isHistoryPaused: !1,\n          pausedHistory: [],\n          isBatching: !1,\n          batch: {\n            ops: [],\n            updates: { storageUpdates: new Map(), presence: !1, others: [] },\n            reverseOps: [],\n          },\n          offlineOperations: new Map(),\n        };\n      })(\n        \"function\" == typeof initialPresence\n          ? initialPresence(context.roomId)\n          : initialPresence,\n        \"function\" == typeof initialStorage\n          ? initialStorage(context.roomId)\n          : initialStorage\n      ),\n      context\n    ),\n    room = {\n      id: context.roomId,\n      getConnectionState: machine.selectors.getConnectionState,\n      getSelf: machine.selectors.getSelf,\n      subscribe: machine.subscribe,\n      getPresence: machine.selectors.getPresence,\n      updatePresence: machine.updatePresence,\n      getOthers: machine.selectors.getOthers,\n      broadcastEvent: machine.broadcastEvent,\n      getStorage: machine.getStorage,\n      batch: machine.batch,\n      history: {\n        undo: machine.undo,\n        redo: machine.redo,\n        pause: machine.pauseHistory,\n        resume: machine.resumeHistory,\n      },\n      __INTERNAL_DO_NOT_USE: {\n        simulateCloseWebsocket: machine.simulateSocketClose,\n        simulateSendCloseEvent: machine.simulateSendCloseEvent,\n      },\n    };\n  return {\n    connect: machine.connect,\n    disconnect: machine.disconnect,\n    onNavigatorOnline: machine.onNavigatorOnline,\n    onVisibilityChange: machine.onVisibilityChange,\n    room: room,\n  };\n}\nclass LiveblocksError extends Error {\n  constructor(message, code) {\n    super(message), (this.code = code);\n  }\n}\nfunction fetchAuthEndpoint(fetch, endpoint, body) {\n  return fetch(endpoint, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(body),\n  })\n    .then((res) => {\n      if (!res.ok)\n        throw new AuthenticationError(\n          `Expected a status 200 but got ${res.status} when doing a POST request on \"${endpoint}\"`\n        );\n      return res.json().catch((er) => {\n        throw new AuthenticationError(\n          `Expected a JSON response when doing a POST request on \"${endpoint}\". ${er}`\n        );\n      });\n    })\n    .then((data) => {\n      if (!(0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(data) || \"string\" != typeof data.token)\n        throw new AuthenticationError(\n          `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n            data\n          )}`\n        );\n      const { token: token } = data;\n      return { token: token };\n    });\n}\nclass AuthenticationError extends Error {\n  constructor(message) {\n    super(message);\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options,\n    throttleDelay = (function (options) {\n      if (void 0 === options.throttle) return 100;\n      if (\n        \"number\" != typeof options.throttle ||\n        options.throttle < 80 ||\n        options.throttle > 1e3\n      )\n        throw new Error(\"throttle should be a number between 80 and 1000.\");\n      return options.throttle;\n    })(options),\n    rooms = new Map();\n  return (\n    \"undefined\" != typeof window &&\n      void 0 !== window.addEventListener &&\n      window.addEventListener(\"online\", () => {\n        for (const [, room] of rooms) room.onNavigatorOnline();\n      }),\n    \"undefined\" != typeof document &&\n      document.addEventListener(\"visibilitychange\", () => {\n        for (const [, room] of rooms)\n          room.onVisibilityChange(document.visibilityState);\n      }),\n    {\n      getRoom: function (roomId) {\n        const internalRoom = rooms.get(roomId);\n        return internalRoom ? internalRoom.room : null;\n      },\n      enter: function (roomId, options = {}) {\n        var _a;\n        let internalRoom = rooms.get(roomId);\n        if (internalRoom) return internalRoom.room;\n        if (\n          ((0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(\n            options.defaultPresence,\n            \"Argument `defaultPresence` will be removed in @liveblocks/client 0.18. Please use `initialPresence` instead. For more info, see https://bit.ly/3Niy5aP\"\n          ),\n          (0,_shared_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(\n            options.defaultStorageRoot,\n            \"Argument `defaultStorageRoot` will be removed in @liveblocks/client 0.18. Please use `initialStorage` instead. For more info, see https://bit.ly/3Niy5aP\"\n          ),\n          (internalRoom = createRoom(\n            {\n              initialPresence: options.initialPresence,\n              initialStorage: options.initialStorage,\n              defaultPresence: options.defaultPresence,\n              defaultStorageRoot: options.defaultStorageRoot,\n            },\n            {\n              roomId: roomId,\n              throttleDelay: throttleDelay,\n              polyfills: clientOptions.polyfills,\n              WebSocketPolyfill: clientOptions.WebSocketPolyfill,\n              fetchPolyfill: clientOptions.fetchPolyfill,\n              liveblocksServer:\n                (null == clientOptions\n                  ? void 0\n                  : clientOptions.liveblocksServer) ||\n                \"wss://liveblocks.net/v6\",\n              authentication: prepareAuthentication(clientOptions),\n            }\n          )),\n          rooms.set(roomId, internalRoom),\n          !options.DO_NOT_USE_withoutConnecting)\n        ) {\n          if (\"undefined\" == typeof atob) {\n            if (\n              null ==\n              (null === (_a = clientOptions.polyfills) || void 0 === _a\n                ? void 0\n                : _a.atob)\n            )\n              throw new Error(\n                \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n              );\n            global.atob = clientOptions.polyfills.atob;\n          }\n          internalRoom.connect();\n        }\n        return internalRoom.room;\n      },\n      leave: function (roomId) {\n        const room = rooms.get(roomId);\n        room && (room.disconnect(), rooms.delete(roomId));\n      },\n    }\n  );\n}\nfunction prepareAuthentication(clientOptions) {\n  const { publicApiKey: publicApiKey, authEndpoint: authEndpoint } =\n    clientOptions;\n  if (void 0 !== authEndpoint && void 0 !== publicApiKey)\n    throw new Error(\n      \"You cannot use both publicApiKey and authEndpoint. Please use either publicApiKey or authEndpoint, but not both. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  if (\"string\" == typeof publicApiKey) {\n    if (publicApiKey.startsWith(\"sk_\"))\n      throw new Error(\n        \"Invalid publicApiKey. You are using the secret key which is not supported. Please use the public key instead. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    if (!publicApiKey.startsWith(\"pk_\"))\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    return {\n      type: \"public\",\n      publicApiKey: publicApiKey,\n      url:\n        clientOptions.publicAuthorizeEndpoint ||\n        \"https://liveblocks.io/api/public/authorize\",\n    };\n  }\n  if (\"string\" == typeof authEndpoint)\n    return { type: \"private\", url: authEndpoint };\n  if (\"function\" == typeof authEndpoint)\n    return { type: \"custom\", callback: authEndpoint };\n  if (void 0 !== authEndpoint)\n    throw new Error(\n      \"authEndpoint must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  throw new Error(\n    \"Invalid Liveblocks client options. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\n\n\n\n//# sourceURL=webpack://marketing-oembed-meeting-tools/./node_modules/@liveblocks/client/index.mjs?");

/***/ }),

/***/ "./node_modules/@liveblocks/client/shared.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@liveblocks/client/shared.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"A\": () => (/* binding */ isRoomAuthToken),\n/* harmony export */   \"B\": () => (/* binding */ isScope),\n/* harmony export */   \"C\": () => (/* binding */ ClientMsgCode),\n/* harmony export */   \"D\": () => (/* binding */ deprecate),\n/* harmony export */   \"E\": () => (/* binding */ deprecateIf),\n/* harmony export */   \"F\": () => (/* binding */ throwUsageError),\n/* harmony export */   \"G\": () => (/* binding */ comparePosition),\n/* harmony export */   \"H\": () => (/* binding */ makePosition),\n/* harmony export */   \"I\": () => (/* binding */ CrdtType),\n/* harmony export */   \"J\": () => (/* binding */ isJsonScalar),\n/* harmony export */   \"K\": () => (/* binding */ isChildCrdt),\n/* harmony export */   \"L\": () => (/* binding */ LiveObject),\n/* harmony export */   \"M\": () => (/* binding */ b64decode),\n/* harmony export */   \"O\": () => (/* binding */ OpSource),\n/* harmony export */   \"S\": () => (/* binding */ ServerMsgCode),\n/* harmony export */   \"W\": () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   \"_\": () => (/* binding */ __rest),\n/* harmony export */   \"a\": () => (/* binding */ isRoomEventName),\n/* harmony export */   \"b\": () => (/* binding */ isPlainObject),\n/* harmony export */   \"c\": () => (/* binding */ isTokenExpired),\n/* harmony export */   \"d\": () => (/* binding */ isSameNodeOrChildOf),\n/* harmony export */   \"e\": () => (/* binding */ OpCode),\n/* harmony export */   \"f\": () => (/* binding */ isLiveList),\n/* harmony export */   \"g\": () => (/* binding */ getTreesDiffOperations),\n/* harmony export */   \"h\": () => (/* binding */ isJsonArray),\n/* harmony export */   \"i\": () => (/* binding */ isLiveNode),\n/* harmony export */   \"j\": () => (/* binding */ compact),\n/* harmony export */   \"k\": () => (/* binding */ isRootCrdt),\n/* harmony export */   \"l\": () => (/* binding */ isJsonObject),\n/* harmony export */   \"m\": () => (/* binding */ mergeStorageUpdates),\n/* harmony export */   \"n\": () => (/* binding */ nn),\n/* harmony export */   \"o\": () => (/* binding */ errorIf),\n/* harmony export */   \"p\": () => (/* binding */ parseRoomAuthToken),\n/* harmony export */   \"q\": () => (/* binding */ LiveList),\n/* harmony export */   \"r\": () => (/* binding */ remove),\n/* harmony export */   \"s\": () => (/* binding */ LiveMap),\n/* harmony export */   \"t\": () => (/* binding */ tryParseJson),\n/* harmony export */   \"u\": () => (/* binding */ LiveRegister),\n/* harmony export */   \"v\": () => (/* binding */ findNonSerializableValue),\n/* harmony export */   \"w\": () => (/* binding */ isLiveObject),\n/* harmony export */   \"x\": () => (/* binding */ assertNever),\n/* harmony export */   \"y\": () => (/* binding */ isAppOnlyAuthToken),\n/* harmony export */   \"z\": () => (/* binding */ isAuthToken)\n/* harmony export */ });\nconst _emittedDeprecationWarnings = new Set();\nfunction deprecate(message, key = message) {\n   true &&\n    (_emittedDeprecationWarnings.has(key) ||\n      (_emittedDeprecationWarnings.add(key),\n      console.error(`DEPRECATION WARNING: ${message}`)));\n}\nfunction deprecateIf(condition, message, key = message) {\n   true && condition && deprecate(message, key);\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    throw ((usageError.name = \"Usage error\"), usageError);\n  }\n}\nfunction errorIf(condition, message) {\n   true &&\n    condition &&\n    throwUsageError(message);\n}\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s)\n    Object.prototype.hasOwnProperty.call(s, p) &&\n      e.indexOf(p) < 0 &&\n      (t[p] = s[p]);\n  if (null != s && \"function\" == typeof Object.getOwnPropertySymbols) {\n    var i = 0;\n    for (p = Object.getOwnPropertySymbols(s); i < p.length; i++)\n      e.indexOf(p[i]) < 0 &&\n        Object.prototype.propertyIsEnumerable.call(s, p[i]) &&\n        (t[p[i]] = s[p[i]]);\n  }\n  return t;\n}\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  return (\n    (function (condition, errmsg) {\n      if ( true && !condition) {\n        const err = new Error(errmsg);\n        throw ((err.name = \"Assertion failure\"), err);\n      }\n    })(null != value, errmsg),\n    value\n  );\n}\nvar ClientMsgCode,\n  OpCode,\n  CrdtType,\n  ServerMsgCode,\n  WebsocketCloseCodes,\n  OpSource;\nfunction isRootCrdt(crdt) {\n  return crdt.type === CrdtType.OBJECT && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return void 0 !== crdt.parentId && void 0 !== crdt.parentKey;\n}\nfunction isRoomEventName(value) {\n  return (\n    \"my-presence\" === value ||\n    \"others\" === value ||\n    \"event\" === value ||\n    \"error\" === value ||\n    \"connection\" === value\n  );\n}\nfunction HasParent(node, key) {\n  return Object.freeze({ type: \"HasParent\", node: node, key: key });\n}\n!(function (ClientMsgCode) {\n  (ClientMsgCode[(ClientMsgCode.UPDATE_PRESENCE = 100)] = \"UPDATE_PRESENCE\"),\n    (ClientMsgCode[(ClientMsgCode.BROADCAST_EVENT = 103)] = \"BROADCAST_EVENT\"),\n    (ClientMsgCode[(ClientMsgCode.FETCH_STORAGE = 200)] = \"FETCH_STORAGE\"),\n    (ClientMsgCode[(ClientMsgCode.UPDATE_STORAGE = 201)] = \"UPDATE_STORAGE\");\n})(ClientMsgCode || (ClientMsgCode = {})),\n  (function (OpCode) {\n    (OpCode[(OpCode.INIT = 0)] = \"INIT\"),\n      (OpCode[(OpCode.SET_PARENT_KEY = 1)] = \"SET_PARENT_KEY\"),\n      (OpCode[(OpCode.CREATE_LIST = 2)] = \"CREATE_LIST\"),\n      (OpCode[(OpCode.UPDATE_OBJECT = 3)] = \"UPDATE_OBJECT\"),\n      (OpCode[(OpCode.CREATE_OBJECT = 4)] = \"CREATE_OBJECT\"),\n      (OpCode[(OpCode.DELETE_CRDT = 5)] = \"DELETE_CRDT\"),\n      (OpCode[(OpCode.DELETE_OBJECT_KEY = 6)] = \"DELETE_OBJECT_KEY\"),\n      (OpCode[(OpCode.CREATE_MAP = 7)] = \"CREATE_MAP\"),\n      (OpCode[(OpCode.CREATE_REGISTER = 8)] = \"CREATE_REGISTER\");\n  })(OpCode || (OpCode = {})),\n  (function (CrdtType) {\n    (CrdtType[(CrdtType.OBJECT = 0)] = \"OBJECT\"),\n      (CrdtType[(CrdtType.LIST = 1)] = \"LIST\"),\n      (CrdtType[(CrdtType.MAP = 2)] = \"MAP\"),\n      (CrdtType[(CrdtType.REGISTER = 3)] = \"REGISTER\");\n  })(CrdtType || (CrdtType = {})),\n  (function (ServerMsgCode) {\n    (ServerMsgCode[(ServerMsgCode.UPDATE_PRESENCE = 100)] = \"UPDATE_PRESENCE\"),\n      (ServerMsgCode[(ServerMsgCode.USER_JOINED = 101)] = \"USER_JOINED\"),\n      (ServerMsgCode[(ServerMsgCode.USER_LEFT = 102)] = \"USER_LEFT\"),\n      (ServerMsgCode[(ServerMsgCode.BROADCASTED_EVENT = 103)] =\n        \"BROADCASTED_EVENT\"),\n      (ServerMsgCode[(ServerMsgCode.ROOM_STATE = 104)] = \"ROOM_STATE\"),\n      (ServerMsgCode[(ServerMsgCode.INITIAL_STORAGE_STATE = 200)] =\n        \"INITIAL_STORAGE_STATE\"),\n      (ServerMsgCode[(ServerMsgCode.UPDATE_STORAGE = 201)] = \"UPDATE_STORAGE\");\n  })(ServerMsgCode || (ServerMsgCode = {})),\n  (function (WebsocketCloseCodes) {\n    (WebsocketCloseCodes[(WebsocketCloseCodes.CLOSE_ABNORMAL = 1006)] =\n      \"CLOSE_ABNORMAL\"),\n      (WebsocketCloseCodes[(WebsocketCloseCodes.INVALID_MESSAGE_FORMAT = 4e3)] =\n        \"INVALID_MESSAGE_FORMAT\"),\n      (WebsocketCloseCodes[(WebsocketCloseCodes.NOT_ALLOWED = 4001)] =\n        \"NOT_ALLOWED\"),\n      (WebsocketCloseCodes[\n        (WebsocketCloseCodes.MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002)\n      ] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"),\n      (WebsocketCloseCodes[\n        (WebsocketCloseCodes.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003)\n      ] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"),\n      (WebsocketCloseCodes[\n        (WebsocketCloseCodes.MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004)\n      ] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"),\n      (WebsocketCloseCodes[\n        (WebsocketCloseCodes.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005)\n      ] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"),\n      (WebsocketCloseCodes[(WebsocketCloseCodes.CLOSE_WITHOUT_RETRY = 4999)] =\n        \"CLOSE_WITHOUT_RETRY\");\n  })(WebsocketCloseCodes || (WebsocketCloseCodes = {})),\n  (function (OpSource) {\n    (OpSource[(OpSource.UNDOREDO_RECONNECT = 0)] = \"UNDOREDO_RECONNECT\"),\n      (OpSource[(OpSource.REMOTE = 1)] = \"REMOTE\"),\n      (OpSource[(OpSource.ACK = 2)] = \"ACK\");\n  })(OpSource || (OpSource = {}));\nconst NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey) {\n  return Object.freeze({ type: \"Orphaned\", oldKey: oldKey });\n}\nclass AbstractCrdt {\n  constructor() {\n    this._parent = NoParent;\n  }\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  get _doc() {\n    return this.__doc;\n  }\n  get roomId() {\n    return this.__doc ? this.__doc.roomId : null;\n  }\n  get _id() {\n    return this.__id;\n  }\n  get parent() {\n    return this._parent;\n  }\n  get _parentNode() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.node;\n      case \"NoParent\":\n      case \"Orphaned\":\n        return null;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  _apply(op, _isLocal) {\n    return op.type === OpCode.DELETE_CRDT && \"HasParent\" === this.parent.type\n      ? this.parent.node._detachChild(this)\n      : { modified: !1 };\n  }\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode)\n          throw new Error(\"Cannot attach parent if it already exist\");\n        return void (this._parent = HasParent(newParentNode, newParentKey));\n      case \"Orphaned\":\n      case \"NoParent\":\n        return void (this._parent = HasParent(newParentNode, newParentKey));\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  _attach(id, doc) {\n    if (this.__id || this.__doc)\n      throw new Error(\"Cannot attach if CRDT is already attached\");\n    doc.addItem(id, this), (this.__id = id), (this.__doc = doc);\n  }\n  _detach() {\n    switch (\n      (this.__doc && this.__id && this.__doc.deleteItem(this.__id),\n      this.parent.type)\n    ) {\n      case \"HasParent\":\n        this._parent = Orphaned(this.parent.key);\n        break;\n      case \"NoParent\":\n        this._parent = NoParent;\n        break;\n      case \"Orphaned\":\n        this._parent = Orphaned(this.parent.oldKey);\n        break;\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__doc = void 0;\n  }\n}\nclass LiveRegister extends AbstractCrdt {\n  constructor(data) {\n    super(), (this._data = data);\n  }\n  get data() {\n    return this._data;\n  }\n  static _deserialize([id, item], _parentToChildren, doc) {\n    const register = new LiveRegister(item.data);\n    return register._attach(id, doc), register;\n  }\n  _serialize(parentId, parentKey, doc) {\n    if (null == this._id || null == parentId || null == parentKey)\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    return [\n      {\n        type: OpCode.CREATE_REGISTER,\n        opId: null == doc ? void 0 : doc.generateOpId(),\n        id: this._id,\n        parentId: parentId,\n        parentKey: parentKey,\n        data: this.data,\n      },\n    ];\n  }\n  _toSerializedCrdt() {\n    if (\"HasParent\" !== this.parent.type)\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    return {\n      type: CrdtType.REGISTER,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data,\n    };\n  }\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n}\nfunction makePosition(before, after) {\n  return null != before && null != after\n    ? pos(makePositionFromCodes(posCodes(before), posCodes(after)))\n    : null != before\n    ? (function (before) {\n        const result = [],\n          beforeCodes = posCodes(before);\n        for (let i = 0; i < beforeCodes.length; i++) {\n          const code = beforeCodes[i];\n          if (126 !== code) {\n            result.push(code + 1);\n            break;\n          }\n          if ((result.push(code), beforeCodes.length - 1 === i)) {\n            result.push(33);\n            break;\n          }\n        }\n        return pos(result);\n      })(before)\n    : null != after\n    ? (function (after) {\n        const result = [],\n          afterCodes = posCodes(after);\n        for (let i = 0; i < afterCodes.length; i++) {\n          const code = afterCodes[i];\n          if (!(code <= 33)) {\n            result.push(code - 1);\n            break;\n          }\n          if ((result.push(32), afterCodes.length - 1 === i)) {\n            result.push(126);\n            break;\n          }\n        }\n        return pos(result);\n      })(after)\n    : pos([33]);\n}\nfunction makePositionFromCodes(before, after) {\n  let index = 0;\n  const result = [];\n  for (;;) {\n    const beforeDigit = before[index] || 32,\n      afterDigit = after[index] || 126;\n    if (beforeDigit > afterDigit)\n      throw new Error(\n        `Impossible to generate position between ${before} and ${after}`\n      );\n    if (beforeDigit === afterDigit) {\n      result.push(beforeDigit), index++;\n      continue;\n    }\n    if (afterDigit - beforeDigit == 1) {\n      result.push(beforeDigit),\n        result.push(...makePositionFromCodes(before.slice(index + 1), []));\n      break;\n    }\n    const mid = (afterDigit + beforeDigit) >> 1;\n    result.push(mid);\n    break;\n  }\n  return result;\n}\nfunction posCodes(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) codes.push(str.charCodeAt(i));\n  return codes;\n}\nfunction pos(codes) {\n  return String.fromCharCode(...codes);\n}\nfunction comparePosition(posA, posB) {\n  const aCodes = posCodes(posA),\n    bCodes = posCodes(posB),\n    maxLength = Math.max(aCodes.length, bCodes.length);\n  for (let i = 0; i < maxLength; i++) {\n    const a = null == aCodes[i] ? 32 : aCodes[i],\n      b = null == bCodes[i] ? 32 : bCodes[i];\n    if (a !== b) return a - b;\n  }\n  throw new Error(\n    `Impossible to compare similar position \"${posA}\" and \"${posB}\"`\n  );\n}\nclass LiveList extends AbstractCrdt {\n  constructor(items = []) {\n    let position;\n    super(),\n      (this._items = []),\n      (this._implicitlyDeletedItems = new Set()),\n      (this._unacknowledgedSets = new Map());\n    for (let i = 0; i < items.length; i++) {\n      const newPosition = makePosition(position),\n        item = lsonToLiveNode(items[i]);\n      item._setParentLink(this, newPosition),\n        this._items.push(item),\n        (position = newPosition);\n    }\n  }\n  static _deserialize([id], parentToChildren, doc) {\n    const list = new LiveList();\n    list._attach(id, doc);\n    const children = parentToChildren.get(id);\n    if (null == children) return list;\n    for (const [id, crdt] of children) {\n      const child = deserialize([id, crdt], parentToChildren, doc);\n      child._setParentLink(list, crdt.parentKey),\n        list._items.push(child),\n        sortListItem(list._items);\n    }\n    return list;\n  }\n  _serialize(parentId, parentKey, doc) {\n    if (null == this._id)\n      throw new Error(\"Cannot serialize item is not attached\");\n    const ops = [],\n      op = {\n        id: this._id,\n        opId: null == doc ? void 0 : doc.generateOpId(),\n        type: OpCode.CREATE_LIST,\n        parentId: parentId,\n        parentKey: parentKey,\n      };\n    ops.push(op);\n    for (const item of this._items)\n      ops.push(...item._serialize(this._id, item._getParentKeyOrThrow(), doc));\n    return ops;\n  }\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  _attach(id, doc) {\n    super._attach(id, doc);\n    for (const item of this._items) item._attach(doc.generateId(), doc);\n  }\n  _detach() {\n    super._detach();\n    for (const item of this._items) item._detach();\n  }\n  _applySetRemote(op) {\n    if (null == this._doc)\n      throw new Error(\"Can't attach child if doc is not present\");\n    const { id: id, parentKey: key } = op,\n      child = creationOpToLiveNode(op);\n    child._attach(id, this._doc), child._setParentLink(this, key);\n    const deletedId = op.deletedId,\n      indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (-1 !== indexOfItemWithSamePosition) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId)\n        return (\n          itemWithSamePosition._detach(),\n          (this._items[indexOfItemWithSamePosition] = child),\n          {\n            modified: makeUpdate(this, [\n              setDelta(indexOfItemWithSamePosition, child),\n            ]),\n            reverse: [],\n          }\n        );\n      {\n        this._implicitlyDeletedItems.add(itemWithSamePosition),\n          (this._items[indexOfItemWithSamePosition] = child);\n        const delta = [setDelta(indexOfItemWithSamePosition, child)],\n          deleteDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n        return (\n          deleteDelta && delta.push(deleteDelta),\n          { modified: makeUpdate(this, delta), reverse: [] }\n        );\n      }\n    }\n    {\n      const updates = [],\n        deleteDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n      return (\n        deleteDelta && updates.push(deleteDelta),\n        this._items.push(child),\n        sortListItem(this._items),\n        updates.push(insertDelta(this._indexOfPosition(key), child)),\n        { reverse: [], modified: makeUpdate(this, updates) }\n      );\n    }\n  }\n  _applySetAck(op) {\n    if (null == this._doc)\n      throw new Error(\"Can't attach child if doc is not present\");\n    const delta = [],\n      deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    deletedDelta && delta.push(deletedDelta);\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (null != unacknowledgedOpId) {\n      if (unacknowledgedOpId !== op.opId)\n        return 0 === delta.length\n          ? { modified: !1 }\n          : { modified: makeUpdate(this, delta), reverse: [] };\n      this._unacknowledgedSets.delete(op.parentKey);\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey),\n      existingItem = this._items.find((item) => item._id === op.id);\n    if (null != existingItem) {\n      if (existingItem._parentKey === op.parentKey)\n        return {\n          modified: delta.length > 0 && makeUpdate(this, delta),\n          reverse: [],\n        };\n      -1 !== indexOfItemWithSamePosition &&\n        (this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        ),\n        this._items.splice(indexOfItemWithSamePosition, 1),\n        delta.push(deleteDelta(indexOfItemWithSamePosition)));\n      const previousIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey),\n        sortListItem(this._items);\n      const newIndex = this._items.indexOf(existingItem);\n      return (\n        newIndex !== previousIndex &&\n          delta.push(moveDelta(previousIndex, newIndex, existingItem)),\n        { modified: delta.length > 0 && makeUpdate(this, delta), reverse: [] }\n      );\n    }\n    {\n      const orphan = this._doc.getItem(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey),\n          this._implicitlyDeletedItems.delete(orphan),\n          this._items.push(orphan),\n          sortListItem(this._items);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            -1 === indexOfItemWithSamePosition\n              ? insertDelta(recreatedItemIndex, orphan)\n              : setDelta(recreatedItemIndex, orphan),\n            ...delta,\n          ]),\n          reverse: [],\n        };\n      }\n      {\n        -1 !== indexOfItemWithSamePosition &&\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        const { newItem: newItem, newIndex: newIndex } =\n          this._createAttachItemAndSort(op, op.parentKey);\n        return {\n          modified: makeUpdate(this, [\n            -1 === indexOfItemWithSamePosition\n              ? insertDelta(newIndex, newItem)\n              : setDelta(newIndex, newItem),\n            ...delta,\n          ]),\n          reverse: [],\n        };\n      }\n    }\n  }\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (null == deletedId || null == this._doc) return null;\n    const deletedItem = this._doc.getItem(deletedId);\n    if (null == deletedItem) return null;\n    const result = this._detachChild(deletedItem);\n    return !1 === result.modified ? null : result.modified.updates[0];\n  }\n  _applyRemoteInsert(op) {\n    if (null == this._doc)\n      throw new Error(\"Can't attach child if doc is not present\");\n    const key = op.parentKey,\n      existingItemIndex = this._indexOfPosition(key);\n    -1 !== existingItemIndex && this._shiftItemPosition(existingItemIndex, key);\n    const { newItem: newItem, newIndex: newIndex } =\n      this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: [],\n    };\n  }\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id),\n      key = op.parentKey,\n      itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) return { modified: !1 };\n      {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        -1 !== itemIndexAtPosition &&\n          this._shiftItemPosition(itemIndexAtPosition, key),\n          existingItem._setParentLink(this, key),\n          sortListItem(this._items);\n        const newIndex = this._indexOfPosition(key);\n        return newIndex === oldPositionIndex\n          ? { modified: !1 }\n          : {\n              modified: makeUpdate(this, [\n                moveDelta(oldPositionIndex, newIndex, existingItem),\n              ]),\n              reverse: [],\n            };\n      }\n    }\n    {\n      const orphan = nn(this._doc).getItem(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key),\n          this._implicitlyDeletedItems.delete(orphan),\n          this._items.push(orphan),\n          sortListItem(this._items);\n        return {\n          modified: makeUpdate(this, [\n            insertDelta(this._indexOfPosition(key), orphan),\n          ]),\n          reverse: [],\n        };\n      }\n      {\n        -1 !== itemIndexAtPosition &&\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        const { newItem: newItem, newIndex: newIndex } =\n          this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: [],\n        };\n      }\n    }\n  }\n  _applyInsertUndoRedo(op) {\n    var _a;\n    const { id: id, parentKey: key } = op,\n      child = creationOpToLiveNode(op);\n    if (\n      void 0 !==\n      (null === (_a = this._doc) || void 0 === _a ? void 0 : _a.getItem(id))\n    )\n      return { modified: !1 };\n    child._attach(id, nn(this._doc)), child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (-1 !== existingItemIndex) {\n      (newKey = makePosition(\n        this._items[existingItemIndex]\n          ? this._items[existingItemIndex]._getParentKeyOrThrow()\n          : void 0,\n        this._items[existingItemIndex + 1]\n          ? this._items[existingItemIndex + 1]._getParentKeyOrThrow()\n          : void 0\n      )),\n        child._setParentLink(this, newKey);\n    }\n    this._items.push(child), sortListItem(this._items);\n    return {\n      modified: makeUpdate(this, [\n        insertDelta(this._indexOfPosition(newKey), child),\n      ]),\n      reverse: [{ type: OpCode.DELETE_CRDT, id: id }],\n    };\n  }\n  _applySetUndoRedo(op) {\n    var _a;\n    const { id: id, parentKey: key } = op,\n      child = creationOpToLiveNode(op);\n    if (\n      void 0 !==\n      (null === (_a = this._doc) || void 0 === _a ? void 0 : _a.getItem(id))\n    )\n      return { modified: !1 };\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._doc)), child._setParentLink(this, key);\n    const newKey = key;\n    if (-1 !== indexOfItemWithSameKey) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach(), (this._items[indexOfItemWithSameKey] = child);\n      const reverse = existingItem._serialize(nn(this._id), key, this._doc);\n      addIntentAndDeletedIdToOperation(reverse, op.id);\n      const delta = [setDelta(indexOfItemWithSameKey, child)],\n        deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n      return (\n        deletedDelta && delta.push(deletedDelta),\n        { modified: makeUpdate(this, delta), reverse: reverse }\n      );\n    }\n    {\n      this._items.push(child),\n        sortListItem(this._items),\n        this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: OpCode.DELETE_CRDT, id: id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      };\n    }\n  }\n  _attachChild(op, source) {\n    if (null == this._doc)\n      throw new Error(\"Can't attach child if doc is not present\");\n    if (\"set\" === op.intent) {\n      if (source === OpSource.REMOTE) return this._applySetRemote(op);\n      if (source === OpSource.UNDOREDO_RECONNECT)\n        return this._applySetUndoRedo(op);\n      if (source === OpSource.ACK) return this._applySetAck(op);\n    }\n    return source === OpSource.REMOTE\n      ? this._applyRemoteInsert(op)\n      : source === OpSource.ACK\n      ? this._applyInsertAck(op)\n      : this._applyInsertUndoRedo(op);\n  }\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey),\n        reverse = child._serialize(nn(this._id), parentKey, this._doc),\n        indexToDelete = this._items.indexOf(child);\n      return -1 === indexToDelete\n        ? { modified: !1 }\n        : (this._items.splice(indexToDelete, 1),\n          child._detach(),\n          {\n            modified: makeUpdate(this, [deleteDelta(indexToDelete)]),\n            reverse: reverse,\n          });\n    }\n    return { modified: !1 };\n  }\n  _applySetChildKeyRemote(newKey, child) {\n    var _a;\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child),\n        child._setParentLink(this, newKey),\n        this._items.push(child),\n        sortListItem(this._items);\n      return {\n        modified: makeUpdate(this, [\n          insertDelta(this._items.indexOf(child), child),\n        ]),\n        reverse: [],\n      };\n    }\n    if (newKey === child._parentKey) return { modified: !1 };\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (-1 === existingItemIndex) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey), sortListItem(this._items);\n      const newIndex = this._items.indexOf(child);\n      return newIndex === previousIndex\n        ? { modified: !1 }\n        : {\n            modified: makeUpdate(this, [\n              moveDelta(previousIndex, newIndex, child),\n            ]),\n            reverse: [],\n          };\n    }\n    {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(\n          newKey,\n          null === (_a = this._items[existingItemIndex + 1]) || void 0 === _a\n            ? void 0\n            : _a._getParentKeyOrThrow()\n        )\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey), sortListItem(this._items);\n      const newIndex = this._items.indexOf(child);\n      return newIndex === previousIndex\n        ? { modified: !1 }\n        : {\n            modified: makeUpdate(this, [\n              moveDelta(previousIndex, newIndex, child),\n            ]),\n            reverse: [],\n          };\n    }\n  }\n  _applySetChildKeyAck(newKey, child) {\n    var _a, _b;\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      return (\n        this._implicitlyDeletedItems.delete(child),\n        -1 !== existingItemIndex &&\n          this._items[existingItemIndex]._setParentLink(\n            this,\n            makePosition(\n              newKey,\n              null === (_a = this._items[existingItemIndex + 1]) ||\n                void 0 === _a\n                ? void 0\n                : _a._getParentKeyOrThrow()\n            )\n          ),\n        child._setParentLink(this, newKey),\n        this._items.push(child),\n        sortListItem(this._items),\n        { modified: !1 }\n      );\n    }\n    {\n      if (newKey === previousKey) return { modified: !1 };\n      const previousIndex = this._items.indexOf(child),\n        existingItemIndex = this._indexOfPosition(newKey);\n      -1 !== existingItemIndex &&\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(\n            newKey,\n            null === (_b = this._items[existingItemIndex + 1]) || void 0 === _b\n              ? void 0\n              : _b._getParentKeyOrThrow()\n          )\n        ),\n        child._setParentLink(this, newKey),\n        sortListItem(this._items);\n      const newIndex = this._items.indexOf(child);\n      return previousIndex === newIndex\n        ? { modified: !1 }\n        : {\n            modified: makeUpdate(this, [\n              moveDelta(previousIndex, newIndex, child),\n            ]),\n            reverse: [],\n          };\n    }\n  }\n  _applySetChildKeyUndoRedo(newKey, child) {\n    var _a;\n    const previousKey = nn(child._parentKey),\n      previousIndex = this._items.indexOf(child),\n      existingItemIndex = this._indexOfPosition(newKey);\n    -1 !== existingItemIndex &&\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(\n          newKey,\n          null === (_a = this._items[existingItemIndex + 1]) || void 0 === _a\n            ? void 0\n            : _a._getParentKeyOrThrow()\n        )\n      ),\n      child._setParentLink(this, newKey),\n      sortListItem(this._items);\n    const newIndex = this._items.indexOf(child);\n    return previousIndex === newIndex\n      ? { modified: !1 }\n      : {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child),\n          ]),\n          reverse: [\n            {\n              type: OpCode.SET_PARENT_KEY,\n              id: nn(child._id),\n              parentKey: previousKey,\n            },\n          ],\n        };\n  }\n  _setChildKey(newKey, child, source) {\n    return source === OpSource.REMOTE\n      ? this._applySetChildKeyRemote(newKey, child)\n      : source === OpSource.ACK\n      ? this._applySetChildKeyAck(newKey, child)\n      : this._applySetChildKeyUndoRedo(newKey, child);\n  }\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  _toSerializedCrdt() {\n    if (\"HasParent\" !== this.parent.type)\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    return {\n      type: CrdtType.LIST,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n    };\n  }\n  get length() {\n    return this._items.length;\n  }\n  push(element) {\n    return this.insert(element, this.length);\n  }\n  insert(element, index) {\n    if (index < 0 || index > this._items.length)\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this._items.length}`\n      );\n    const position = makePosition(\n        this._items[index - 1]\n          ? this._items[index - 1]._getParentKeyOrThrow()\n          : void 0,\n        this._items[index] ? this._items[index]._getParentKeyOrThrow() : void 0\n      ),\n      value = lsonToLiveNode(element);\n    if (\n      (value._setParentLink(this, position),\n      this._items.push(value),\n      sortListItem(this._items),\n      this._doc && this._id)\n    ) {\n      const id = this._doc.generateId();\n      value._attach(id, this._doc),\n        this._doc.dispatch(\n          value._serialize(this._id, position, this._doc),\n          [{ type: OpCode.DELETE_CRDT, id: id }],\n          new Map([[this._id, makeUpdate(this, [insertDelta(index, value)])]])\n        );\n    }\n  }\n  move(index, targetIndex) {\n    if (targetIndex < 0) throw new Error(\"targetIndex cannot be less than 0\");\n    if (targetIndex >= this._items.length)\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    if (index < 0) throw new Error(\"index cannot be less than 0\");\n    if (index >= this._items.length)\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    let beforePosition = null,\n      afterPosition = null;\n    index < targetIndex\n      ? ((afterPosition =\n          targetIndex === this._items.length - 1\n            ? void 0\n            : this._items[targetIndex + 1]._getParentKeyOrThrow()),\n        (beforePosition = this._items[targetIndex]._getParentKeyOrThrow()))\n      : ((afterPosition = this._items[targetIndex]._getParentKeyOrThrow()),\n        (beforePosition =\n          0 === targetIndex\n            ? void 0\n            : this._items[targetIndex - 1]._getParentKeyOrThrow()));\n    const position = makePosition(beforePosition, afterPosition),\n      item = this._items[index],\n      previousPosition = item._getParentKeyOrThrow();\n    if (\n      (item._setParentLink(this, position),\n      sortListItem(this._items),\n      this._doc && this._id)\n    ) {\n      const storageUpdates = new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])],\n      ]);\n      this._doc.dispatch(\n        [\n          {\n            type: OpCode.SET_PARENT_KEY,\n            id: nn(item._id),\n            opId: this._doc.generateOpId(),\n            parentKey: position,\n          },\n        ],\n        [\n          {\n            type: OpCode.SET_PARENT_KEY,\n            id: nn(item._id),\n            parentKey: previousPosition,\n          },\n        ],\n        storageUpdates\n      );\n    }\n  }\n  delete(index) {\n    if (index < 0 || index >= this._items.length)\n      throw new Error(\n        `Cannot delete list item at index \"\u001d${index}\". index should be between 0 and ${\n          this._items.length - 1\n        }`\n      );\n    const item = this._items[index];\n    if ((item._detach(), this._items.splice(index, 1), this._doc)) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index)])\n        ),\n          this._doc.dispatch(\n            [\n              {\n                id: childRecordId,\n                opId: this._doc.generateOpId(),\n                type: OpCode.DELETE_CRDT,\n              },\n            ],\n            item._serialize(nn(this._id), item._getParentKeyOrThrow()),\n            storageUpdates\n          );\n      }\n    }\n  }\n  clear() {\n    if (this._doc) {\n      const ops = [],\n        reverseOps = [],\n        updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        childId &&\n          (ops.push({\n            type: OpCode.DELETE_CRDT,\n            id: childId,\n            opId: this._doc.generateOpId(),\n          }),\n          reverseOps.push(\n            ...item._serialize(nn(this._id), item._getParentKeyOrThrow())\n          ),\n          updateDelta.push(deleteDelta(0)));\n      }\n      this._items = [];\n      const storageUpdates = new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta)),\n        this._doc.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) item._detach();\n      this._items = [];\n    }\n  }\n  set(index, item) {\n    if (index < 0 || index >= this._items.length)\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${\n          this._items.length - 1\n        }`\n      );\n    const existingItem = this._items[index],\n      position = existingItem._getParentKeyOrThrow(),\n      existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    if (\n      (value._setParentLink(this, position),\n      (this._items[index] = value),\n      this._doc && this._id)\n    ) {\n      const id = this._doc.generateId();\n      value._attach(id, this._doc);\n      const storageUpdates = new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = value._serialize(this._id, position, this._doc);\n      addIntentAndDeletedIdToOperation(ops, existingId),\n        this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = existingItem._serialize(this._id, position, void 0);\n      addIntentAndDeletedIdToOperation(reverseOps, id),\n        this._doc.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  toArray() {\n    return this._items.map((entry) => liveNodeToLson(entry));\n  }\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  get(index) {\n    if (!(index < 0 || index >= this._items.length))\n      return liveNodeToLson(this._items[index]);\n  }\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  map(callback) {\n    return this._items.map((entry, i) => callback(liveNodeToLson(entry), i));\n  }\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._doc)),\n      newItem._setParentLink(this, key),\n      this._items.push(newItem),\n      sortListItem(this._items);\n    return { newItem: newItem, newIndex: this._indexOfPosition(key) };\n  }\n  _shiftItemPosition(index, key) {\n    var _a;\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1\n        ? null === (_a = this._items[index + 1]) || void 0 === _a\n          ? void 0\n          : _a._getParentKeyOrThrow()\n        : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n}\nclass LiveListIterator {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) return { done: !0, value: void 0 };\n    return { value: liveNodeToLson(result.value) };\n  }\n}\nfunction makeUpdate(liveList, deltaUpdates) {\n  return { node: liveList, type: \"LiveList\", updates: deltaUpdates };\n}\nfunction setDelta(index, item) {\n  return {\n    index: index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item,\n  };\n}\nfunction deleteDelta(index) {\n  return { index: index, type: \"delete\" };\n}\nfunction insertDelta(index, item) {\n  return {\n    index: index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item,\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    index: index,\n    type: \"move\",\n    previousIndex: previousIndex,\n    item: item instanceof LiveRegister ? item.data : item,\n  };\n}\nfunction sortListItem(items) {\n  items.sort((itemA, itemB) =>\n    comparePosition(itemA._getParentKeyOrThrow(), itemB._getParentKeyOrThrow())\n  );\n}\nfunction addIntentAndDeletedIdToOperation(ops, deletedId) {\n  if (0 === ops.length)\n    throw new Error(\n      \"Internal error. Serialized LiveStructure should have at least 1 operation\"\n    );\n  const firstOp = ops[0];\n  (firstOp.intent = \"set\"), (firstOp.deletedId = deletedId);\n}\nclass LiveMap extends AbstractCrdt {\n  constructor(entries) {\n    if (\n      (super(),\n      errorIf(\n        null === entries,\n        \"Support for calling `new LiveMap(null)` will be removed in @liveblocks/client 0.18. Please call as `new LiveMap()`, or `new LiveMap([])`.\"\n      ),\n      (this.unacknowledgedSet = new Map()),\n      entries)\n    ) {\n      const mappedEntries = [];\n      for (const entry of entries) {\n        const value = lsonToLiveNode(entry[1]);\n        value._setParentLink(this, entry[0]),\n          mappedEntries.push([entry[0], value]);\n      }\n      this._map = new Map(mappedEntries);\n    } else this._map = new Map();\n  }\n  _serialize(parentId, parentKey, doc) {\n    if (null == this._id)\n      throw new Error(\"Cannot serialize item is not attached\");\n    const ops = [],\n      op = {\n        id: this._id,\n        opId: null == doc ? void 0 : doc.generateOpId(),\n        type: OpCode.CREATE_MAP,\n        parentId: parentId,\n        parentKey: parentKey,\n      };\n    ops.push(op);\n    for (const [key, value] of this._map)\n      ops.push(...value._serialize(this._id, key, doc));\n    return ops;\n  }\n  static _deserialize([id, _item], parentToChildren, doc) {\n    const map = new LiveMap();\n    map._attach(id, doc);\n    const children = parentToChildren.get(id);\n    if (null == children) return map;\n    for (const [id, crdt] of children) {\n      const child = deserialize([id, crdt], parentToChildren, doc);\n      child._setParentLink(map, crdt.parentKey),\n        map._map.set(crdt.parentKey, child);\n    }\n    return map;\n  }\n  _attach(id, doc) {\n    super._attach(id, doc);\n    for (const [_key, value] of this._map)\n      isLiveNode(value) && value._attach(doc.generateId(), doc);\n  }\n  _attachChild(op, source) {\n    if (null == this._doc)\n      throw new Error(\"Can't attach child if doc is not present\");\n    const { id: id, parentKey: parentKey, opId: opId } = op,\n      key = parentKey,\n      child = creationOpToLiveNode(op);\n    if (void 0 !== this._doc.getItem(id)) return { modified: !1 };\n    if (source === OpSource.ACK) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId)\n        return this.unacknowledgedSet.delete(key), { modified: !1 };\n      if (null != lastUpdateOpId) return { modified: !1 };\n    } else source === OpSource.REMOTE && this.unacknowledgedSet.delete(key);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      (reverse = previousValue._serialize(thisId, key)),\n        previousValue._detach();\n    } else reverse = [{ type: OpCode.DELETE_CRDT, id: id }];\n    return (\n      child._setParentLink(this, key),\n      child._attach(id, this._doc),\n      this._map.set(key, child),\n      {\n        modified: {\n          node: this,\n          type: \"LiveMap\",\n          updates: { [key]: { type: \"update\" } },\n        },\n        reverse: reverse,\n      }\n    );\n  }\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) item._detach();\n  }\n  _detachChild(child) {\n    const id = nn(this._id),\n      parentKey = nn(child._parentKey),\n      reverse = child._serialize(id, parentKey, this._doc);\n    for (const [key, value] of this._map)\n      value === child && this._map.delete(key);\n    child._detach();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [parentKey]: { type: \"delete\" } },\n      },\n      reverse: reverse,\n    };\n  }\n  _toSerializedCrdt() {\n    if (\"HasParent\" !== this.parent.type)\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    return {\n      type: CrdtType.MAP,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n    };\n  }\n  get(key) {\n    const value = this._map.get(key);\n    if (null != value) return liveNodeToLson(value);\n  }\n  set(key, value) {\n    const oldValue = this._map.get(key);\n    oldValue && oldValue._detach();\n    const item = lsonToLiveNode(value);\n    if (\n      (item._setParentLink(this, key),\n      this._map.set(key, item),\n      this._doc && this._id)\n    ) {\n      const id = this._doc.generateId();\n      item._attach(id, this._doc);\n      const storageUpdates = new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } },\n      });\n      const ops = item._serialize(this._id, key, this._doc);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId)),\n        this._doc.dispatch(\n          item._serialize(this._id, key, this._doc),\n          oldValue\n            ? oldValue._serialize(this._id, key)\n            : [{ type: OpCode.DELETE_CRDT, id: id }],\n          storageUpdates\n        );\n    }\n  }\n  get size() {\n    return this._map.size;\n  }\n  has(key) {\n    return this._map.has(key);\n  }\n  delete(key) {\n    const item = this._map.get(key);\n    if (null == item) return !1;\n    if ((item._detach(), this._map.delete(key), this._doc && item._id)) {\n      const thisId = nn(this._id),\n        storageUpdates = new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } },\n      }),\n        this._doc.dispatch(\n          [\n            {\n              type: OpCode.DELETE_CRDT,\n              id: item._id,\n              opId: this._doc.generateOpId(),\n            },\n          ],\n          item._serialize(thisId, key),\n          storageUpdates\n        );\n    }\n    return !0;\n  }\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) return { done: !0, value: void 0 };\n        return {\n          value: [\n            iteratorValue.value[0],\n            liveNodeToLson(iteratorValue.value[1]),\n          ],\n        };\n      },\n    };\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  keys() {\n    return this._map.keys();\n  }\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) return { done: !0, value: void 0 };\n        return { value: liveNodeToLson(iteratorValue.value) };\n      },\n    };\n  }\n  forEach(callback) {\n    for (const entry of this) callback(entry[1], entry[0], this);\n  }\n}\nclass LiveObject extends AbstractCrdt {\n  constructor(obj = {}) {\n    super(), (this._propToLastUpdate = new Map());\n    for (const key in obj) {\n      const value = obj[key];\n      void 0 !== value && isLiveNode(value) && value._setParentLink(this, key);\n    }\n    this._map = new Map(Object.entries(obj));\n  }\n  _serialize(parentId, parentKey, doc) {\n    if (null == this._id)\n      throw new Error(\"Cannot serialize item is not attached\");\n    const opId = null == doc ? void 0 : doc.generateOpId(),\n      ops = [],\n      op =\n        void 0 !== parentId && void 0 !== parentKey\n          ? {\n              type: OpCode.CREATE_OBJECT,\n              id: this._id,\n              opId: opId,\n              parentId: parentId,\n              parentKey: parentKey,\n              data: {},\n            }\n          : { type: OpCode.CREATE_OBJECT, id: this._id, opId: opId, data: {} };\n    ops.push(op);\n    for (const [key, value] of this._map)\n      isLiveNode(value)\n        ? ops.push(...value._serialize(this._id, key, doc))\n        : (op.data[key] = value);\n    return ops;\n  }\n  static _deserialize([id, item], parentToChildren, doc) {\n    const liveObj = new LiveObject(item.data);\n    return (\n      liveObj._attach(id, doc),\n      this._deserializeChildren(liveObj, parentToChildren, doc)\n    );\n  }\n  static _deserializeChildren(liveObj, parentToChildren, doc) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (null == children) return liveObj;\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, doc);\n      isLiveStructure(child) && child._setParentLink(liveObj, crdt.parentKey),\n        liveObj._map.set(crdt.parentKey, child);\n    }\n    return liveObj;\n  }\n  _attach(id, doc) {\n    super._attach(id, doc);\n    for (const [_key, value] of this._map)\n      isLiveNode(value) && value._attach(doc.generateId(), doc);\n  }\n  _attachChild(op, source) {\n    if (null == this._doc)\n      throw new Error(\"Can't attach child if doc is not present\");\n    const { id: id, opId: opId, parentKey: key } = op,\n      child = creationOpToLson(op);\n    if (void 0 !== this._doc.getItem(id))\n      return (\n        this._propToLastUpdate.get(key) === opId &&\n          this._propToLastUpdate.delete(key),\n        { modified: !1 }\n      );\n    if (source === OpSource.UNDOREDO_RECONNECT)\n      this._propToLastUpdate.set(key, nn(opId));\n    else if (void 0 !== this._propToLastUpdate.get(key))\n      return this._propToLastUpdate.get(key) === opId\n        ? (this._propToLastUpdate.delete(key), { modified: !1 })\n        : { modified: !1 };\n    const thisId = nn(this._id),\n      previousValue = this._map.get(key);\n    let reverse;\n    return (\n      isLiveNode(previousValue)\n        ? ((reverse = previousValue._serialize(thisId, key)),\n          previousValue._detach())\n        : (reverse =\n            void 0 === previousValue\n              ? [{ type: OpCode.DELETE_OBJECT_KEY, id: thisId, key: key }]\n              : [\n                  {\n                    type: OpCode.UPDATE_OBJECT,\n                    id: thisId,\n                    data: { [key]: previousValue },\n                  },\n                ]),\n      this._map.set(key, child),\n      isLiveStructure(child) &&\n        (child._setParentLink(this, key), child._attach(id, this._doc)),\n      {\n        reverse: reverse,\n        modified: {\n          node: this,\n          type: \"LiveObject\",\n          updates: { [key]: { type: \"update\" } },\n        },\n      }\n    );\n  }\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id),\n        parentKey = nn(child._parentKey),\n        reverse = child._serialize(id, parentKey, this._doc);\n      for (const [key, value] of this._map)\n        value === child && this._map.delete(key);\n      child._detach();\n      return {\n        modified: {\n          node: this,\n          type: \"LiveObject\",\n          updates: { [parentKey]: { type: \"delete\" } },\n        },\n        reverse: reverse,\n      };\n    }\n    return { modified: !1 };\n  }\n  _detach() {\n    super._detach();\n    for (const value of this._map.values())\n      isLiveNode(value) && value._detach();\n  }\n  _apply(op, isLocal) {\n    return op.type === OpCode.UPDATE_OBJECT\n      ? this._applyUpdate(op, isLocal)\n      : op.type === OpCode.DELETE_OBJECT_KEY\n      ? this._applyDeleteObjectKey(op)\n      : super._apply(op, isLocal);\n  }\n  _toSerializedCrdt() {\n    const data = {};\n    for (const [key, value] of this._map)\n      isLiveNode(value) || (data[key] = value);\n    return \"HasParent\" === this.parent.type && this.parent.node._id\n      ? {\n          type: CrdtType.OBJECT,\n          parentId: this.parent.node._id,\n          parentKey: this.parent.key,\n          data: data,\n        }\n      : { type: CrdtType.OBJECT, data: data };\n  }\n  _applyUpdate(op, isLocal) {\n    let isModified = !1;\n    const id = nn(this._id),\n      reverse = [],\n      reverseUpdate = { type: OpCode.UPDATE_OBJECT, id: id, data: {} };\n    reverse.push(reverseUpdate);\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      isLiveNode(oldValue)\n        ? (reverse.push(...oldValue._serialize(id, key)), oldValue._detach())\n        : void 0 !== oldValue\n        ? (reverseUpdate.data[key] = oldValue)\n        : void 0 === oldValue &&\n          reverse.push({ type: OpCode.DELETE_OBJECT_KEY, id: id, key: key });\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (void 0 === value) continue;\n      if (isLocal) this._propToLastUpdate.set(key, nn(op.opId));\n      else {\n        if (null != this._propToLastUpdate.get(key)) {\n          if (this._propToLastUpdate.get(key) === op.opId) {\n            this._propToLastUpdate.delete(key);\n            continue;\n          }\n          continue;\n        }\n        isModified = !0;\n      }\n      const oldValue = this._map.get(key);\n      isLiveNode(oldValue) && oldValue._detach(),\n        (isModified = !0),\n        (updateDelta[key] = { type: \"update\" }),\n        this._map.set(key, value);\n    }\n    return (\n      0 !== Object.keys(reverseUpdate.data).length &&\n        reverse.unshift(reverseUpdate),\n      isModified\n        ? {\n            modified: { node: this, type: \"LiveObject\", updates: updateDelta },\n            reverse: reverse,\n          }\n        : { modified: !1 }\n    );\n  }\n  _applyDeleteObjectKey(op) {\n    const key = op.key;\n    if (!1 === this._map.has(key)) return { modified: !1 };\n    if (void 0 !== this._propToLastUpdate.get(key)) return { modified: !1 };\n    const oldValue = this._map.get(key),\n      id = nn(this._id);\n    let reverse = [];\n    return (\n      isLiveNode(oldValue)\n        ? ((reverse = oldValue._serialize(id, op.key)), oldValue._detach())\n        : void 0 !== oldValue &&\n          (reverse = [\n            { type: OpCode.UPDATE_OBJECT, id: id, data: { [key]: oldValue } },\n          ]),\n      this._map.delete(key),\n      {\n        modified: {\n          node: this,\n          type: \"LiveObject\",\n          updates: { [op.key]: { type: \"delete\" } },\n        },\n        reverse: reverse,\n      }\n    );\n  }\n  toObject() {\n    return (function (iterable) {\n      const obj = {};\n      for (const [key, val] of iterable) obj[key] = val;\n      return obj;\n    })(this._map);\n  }\n  set(key, value) {\n    this.update({ [key]: value });\n  }\n  get(key) {\n    return this._map.get(key);\n  }\n  delete(key) {\n    const keyAsString = key,\n      oldValue = this._map.get(keyAsString);\n    if (void 0 === oldValue) return;\n    if (null == this._doc || null == this._id)\n      return (\n        isLiveNode(oldValue) && oldValue._detach(),\n        void this._map.delete(keyAsString)\n      );\n    let reverse;\n    isLiveNode(oldValue)\n      ? (oldValue._detach(),\n        (reverse = oldValue._serialize(this._id, keyAsString)))\n      : (reverse = [\n          {\n            type: OpCode.UPDATE_OBJECT,\n            data: { [keyAsString]: oldValue },\n            id: this._id,\n          },\n        ]),\n      this._map.delete(keyAsString);\n    const storageUpdates = new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } },\n    }),\n      this._doc.dispatch(\n        [\n          {\n            type: OpCode.DELETE_OBJECT_KEY,\n            key: keyAsString,\n            id: this._id,\n            opId: this._doc.generateOpId(),\n          },\n        ],\n        reverse,\n        storageUpdates\n      );\n  }\n  update(overrides) {\n    if (null == this._doc || null == this._id) {\n      for (const key in overrides) {\n        const newValue = overrides[key];\n        if (void 0 === newValue) continue;\n        const oldValue = this._map.get(key);\n        isLiveNode(oldValue) && oldValue._detach(),\n          isLiveNode(newValue) && newValue._setParentLink(this, key),\n          this._map.set(key, newValue);\n      }\n      return;\n    }\n    const ops = [],\n      reverseOps = [],\n      opId = this._doc.generateOpId(),\n      updatedProps = {},\n      reverseUpdateOp = { id: this._id, type: OpCode.UPDATE_OBJECT, data: {} },\n      updateDelta = {};\n    for (const key in overrides) {\n      const newValue = overrides[key];\n      if (void 0 === newValue) continue;\n      const oldValue = this._map.get(key);\n      if (\n        (isLiveNode(oldValue)\n          ? (reverseOps.push(...oldValue._serialize(this._id, key)),\n            oldValue._detach())\n          : void 0 === oldValue\n          ? reverseOps.push({\n              type: OpCode.DELETE_OBJECT_KEY,\n              id: this._id,\n              key: key,\n            })\n          : (reverseUpdateOp.data[key] = oldValue),\n        isLiveNode(newValue))\n      ) {\n        newValue._setParentLink(this, key),\n          newValue._attach(this._doc.generateId(), this._doc);\n        const newAttachChildOps = newValue._serialize(this._id, key, this._doc),\n          createCrdtOp = newAttachChildOps.find(\n            (op) => op.parentId === this._id\n          );\n        createCrdtOp && this._propToLastUpdate.set(key, nn(createCrdtOp.opId)),\n          ops.push(...newAttachChildOps);\n      } else\n        (updatedProps[key] = newValue), this._propToLastUpdate.set(key, opId);\n      this._map.set(key, newValue), (updateDelta[key] = { type: \"update\" });\n    }\n    0 !== Object.keys(reverseUpdateOp.data).length &&\n      reverseOps.unshift(reverseUpdateOp),\n      0 !== Object.keys(updatedProps).length &&\n        ops.unshift({\n          opId: opId,\n          id: this._id,\n          type: OpCode.UPDATE_OBJECT,\n          data: updatedProps,\n        });\n    const storageUpdates = new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta,\n    }),\n      this._doc.dispatch(ops, reverseOps, storageUpdates);\n  }\n}\nfunction remove(array, item) {\n  for (let i = 0; i < array.length; i++)\n    if (array[i] === item) {\n      array.splice(i, 1);\n      break;\n    }\n}\nfunction compact(items) {\n  return items.filter((item) => null != item);\n}\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case OpCode.CREATE_REGISTER:\n      return op.data;\n    case OpCode.CREATE_OBJECT:\n      return new LiveObject(op.data);\n    case OpCode.CREATE_MAP:\n      return new LiveMap();\n    case OpCode.CREATE_LIST:\n      return new LiveList();\n    default:\n      return assertNever(0, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  return (\n    node === parent ||\n    (\"HasParent\" === node.parent.type &&\n      isSameNodeOrChildOf(node.parent.node, parent))\n  );\n}\nfunction deserialize([id, crdt], parentToChildren, doc) {\n  switch (crdt.type) {\n    case CrdtType.OBJECT:\n      return LiveObject._deserialize([id, crdt], parentToChildren, doc);\n    case CrdtType.LIST:\n      return LiveList._deserialize([id, crdt], parentToChildren, doc);\n    case CrdtType.MAP:\n      return LiveMap._deserialize([id, crdt], parentToChildren, doc);\n    case CrdtType.REGISTER:\n      return LiveRegister._deserialize([id, crdt], parentToChildren, doc);\n    default:\n      throw new Error(\"Unexpected CRDT type\");\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, doc) {\n  switch (crdt.type) {\n    case CrdtType.OBJECT:\n      return LiveObject._deserialize([id, crdt], parentToChildren, doc);\n    case CrdtType.LIST:\n      return LiveList._deserialize([id, crdt], parentToChildren, doc);\n    case CrdtType.MAP:\n      return LiveMap._deserialize([id, crdt], parentToChildren, doc);\n    case CrdtType.REGISTER:\n      return crdt.data;\n    default:\n      throw new Error(\"Unexpected CRDT type\");\n  }\n}\nfunction isLiveStructure(value) {\n  return (\n    isLiveList(value) ||\n    (function (value) {\n      return value instanceof LiveMap;\n    })(value) ||\n    isLiveObject(value)\n  );\n}\nfunction isLiveNode(value) {\n  return (\n    isLiveStructure(value) ||\n    (function (value) {\n      return value instanceof LiveRegister;\n    })(value)\n  );\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction liveNodeToLson(obj) {\n  return obj instanceof LiveRegister\n    ? obj.data\n    : obj instanceof LiveList ||\n      obj instanceof LiveMap ||\n      obj instanceof LiveObject\n    ? obj\n    : assertNever(0, \"Unknown AbstractCrdt\");\n}\nfunction lsonToLiveNode(value) {\n  return value instanceof LiveObject ||\n    value instanceof LiveMap ||\n    value instanceof LiveList\n    ? value\n    : new LiveRegister(value);\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  return (\n    currentItems.forEach((_, id) => {\n      newItems.get(id) || ops.push({ type: OpCode.DELETE_CRDT, id: id });\n    }),\n    newItems.forEach((crdt, id) => {\n      const currentCrdt = currentItems.get(id);\n      if (currentCrdt)\n        crdt.type === CrdtType.OBJECT &&\n          ((currentCrdt.type === CrdtType.OBJECT &&\n            JSON.stringify(crdt.data) === JSON.stringify(currentCrdt.data)) ||\n            ops.push({ type: OpCode.UPDATE_OBJECT, id: id, data: crdt.data })),\n          crdt.parentKey !== currentCrdt.parentKey &&\n            ops.push({\n              type: OpCode.SET_PARENT_KEY,\n              id: id,\n              parentKey: nn(crdt.parentKey, \"Parent key must not be missing\"),\n            });\n      else\n        switch (crdt.type) {\n          case CrdtType.REGISTER:\n            ops.push({\n              type: OpCode.CREATE_REGISTER,\n              id: id,\n              parentId: crdt.parentId,\n              parentKey: crdt.parentKey,\n              data: crdt.data,\n            });\n            break;\n          case CrdtType.LIST:\n            ops.push({\n              type: OpCode.CREATE_LIST,\n              id: id,\n              parentId: crdt.parentId,\n              parentKey: crdt.parentKey,\n            });\n            break;\n          case CrdtType.OBJECT:\n            ops.push(\n              crdt.parentId\n                ? {\n                    type: OpCode.CREATE_OBJECT,\n                    id: id,\n                    parentId: crdt.parentId,\n                    parentKey: crdt.parentKey,\n                    data: crdt.data,\n                  }\n                : { type: OpCode.CREATE_OBJECT, id: id, data: crdt.data }\n            );\n            break;\n          case CrdtType.MAP:\n            ops.push({\n              type: OpCode.CREATE_MAP,\n              id: id,\n              parentId: crdt.parentId,\n              parentKey: crdt.parentKey,\n            });\n        }\n    }),\n    ops\n  );\n}\nfunction mergeStorageUpdates(first, second) {\n  return first\n    ? \"LiveObject\" === first.type && \"LiveObject\" === second.type\n      ? (function (first, second) {\n          const updates = first.updates;\n          for (const [key, value] of entries(second.updates))\n            updates[key] = value;\n          return Object.assign(Object.assign({}, second), { updates: updates });\n        })(first, second)\n      : \"LiveMap\" === first.type && \"LiveMap\" === second.type\n      ? (function (first, second) {\n          const updates = first.updates;\n          for (const [key, value] of entries(second.updates))\n            updates[key] = value;\n          return Object.assign(Object.assign({}, second), { updates: updates });\n        })(first, second)\n      : \"LiveList\" === first.type && \"LiveList\" === second.type\n      ? (function (first, second) {\n          const updates = first.updates;\n          return Object.assign(Object.assign({}, second), {\n            updates: updates.concat(second.updates),\n          });\n        })(first, second)\n      : second\n    : second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return (\n    null == value ||\n    \"string\" === type ||\n    \"boolean\" === type ||\n    \"number\" === type ||\n    Array.isArray(value) ||\n    isPlainObject(value)\n  );\n}\nfunction isPlainObject(blob) {\n  return (\n    null !== blob &&\n    \"object\" == typeof blob &&\n    \"[object Object]\" === Object.prototype.toString.call(blob)\n  );\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) return { path: path || \"root\", value: value };\n  if (\"object\" != typeof value || null === value) return !1;\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) return { path: nestedPath, value: nestedValue };\n    if (\"object\" == typeof nestedValue) {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) return nonSerializableNestedValue;\n    }\n  }\n  return !1;\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return;\n  }\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    return decodeURIComponent(\n      atob(formattedValue)\n        .split(\"\")\n        .map(function (c) {\n          return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n        .join(\"\")\n    );\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nconst SCOPES = [\n  \"websocket:presence\",\n  \"websocket:storage\",\n  \"room:read\",\n  \"room:write\",\n  \"rooms:read\",\n  \"rooms:write\",\n];\nfunction isTokenExpired(token) {\n  const now = Date.now() / 1e3;\n  return now > token.exp - 300 || now < token.iat + 300;\n}\nfunction isScope(value) {\n  return SCOPES.includes(value);\n}\nfunction isStringList(value) {\n  return Array.isArray(value) && value.every((i) => \"string\" == typeof i);\n}\nfunction isAppOnlyAuthToken(data) {\n  return (\n    \"string\" == typeof data.appId &&\n    void 0 === data.roomId &&\n    isStringList(data.scopes)\n  );\n}\nfunction isRoomAuthToken(data) {\n  return (\n    \"string\" == typeof data.appId &&\n    \"string\" == typeof data.roomId &&\n    \"number\" == typeof data.actor &&\n    (void 0 === data.id || \"string\" == typeof data.id) &&\n    isStringList(data.scopes) &&\n    (void 0 === data.maxConnectionsPerRoom ||\n      \"number\" == typeof data.maxConnectionsPerRoom)\n  );\n}\nfunction isAuthToken(data) {\n  return isAppOnlyAuthToken(data) || isRoomAuthToken(data);\n}\nfunction parseJwtToken(token) {\n  const tokenParts = token.split(\".\");\n  if (3 !== tokenParts.length)\n    throw new Error(\"Authentication error: invalid JWT token\");\n  const data = tryParseJson(b64decode(tokenParts[1]));\n  if (\n    data &&\n    (function (data) {\n      if (!isPlainObject(data)) return !1;\n      const { iat: iat, exp: exp } = data;\n      return \"number\" == typeof iat && \"number\" == typeof exp;\n    })(data)\n  )\n    return data;\n  throw new Error(\"Authentication error: missing JWT metadata\");\n}\nfunction parseRoomAuthToken(tokenString) {\n  const data = parseJwtToken(tokenString);\n  if (data && isRoomAuthToken(data)) {\n    return __rest(data, [\"maxConnections\"]);\n  }\n  throw new Error(\n    \"Authentication error: we expected a room token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n  );\n}\nfunction isJsonScalar(data) {\n  return (\n    null === data ||\n    \"string\" == typeof data ||\n    \"number\" == typeof data ||\n    \"boolean\" == typeof data\n  );\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n\n\n//# sourceURL=webpack://marketing-oembed-meeting-tools/./node_modules/@liveblocks/client/shared.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/wheel-of-random.js");
/******/ 	
/******/ })()
;